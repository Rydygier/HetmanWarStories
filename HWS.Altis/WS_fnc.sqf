RYD_WS_specFor_class =
	[
	];

RYD_WS_recon_class = 
	[
	"o_recon_exp_f",
	"o_recon_f",
	"o_recon_jtac_f",
	"o_recon_lat_f",
	"o_recon_m_f",
	"o_recon_medic_f",
	"o_recon_tl_f",
	"b_recon_exp_f",
	"b_recon_f",
	"b_recon_jtac_f",
	"b_recon_lat_f",
	"b_recon_m_f",
	"b_recon_medic_f",
	"b_recon_tl_f",
	"i_uav_ai",
	"o_uav_ai",
	"b_uav_ai",
	"i_uav_01_f",
	"i_uav_02_cas_f",
	"i_uav_02_f",
	"i_ugv_01_f",
	"i_ugv_01_rcws_f",
	"o_uav_01_f",
	"o_uav_02_cas_f",
	"o_uav_02_f",
	"o_ugv_01_f",
	"o_ugv_01_rcws_f",
	"b_uav_01_f",
	"b_uav_02_cas_f",
	"b_uav_02_f",
	"b_ugv_01_f",
	"b_ugv_01_rcws_f"
	];
	
RYD_WS_FO_class =
	[
	"i_spotter_f",
	"o_spotter_f",
	"b_spotter_f",
	"o_recon_jtac_f",
	"b_recon_jtac_f"
	];
	
RYD_WS_snipers_class = 
	[
	"i_sniper_f",
	"o_sniper_f",
	"b_sniper_f",
	"i_soldier_m_f",
	"o_soldier_m_f",
	"b_g_soldier_m_f",
	"b_soldier_m_f",
	"o_recon_m_f",
	"b_recon_m_f",
	"o_soldieru_m_f"
	];
	
RYD_WS_ATinf_class =
	[
	"i_soldier_at_f",
	"i_soldier_lat_f",
	"o_soldier_at_f",
	"o_soldier_lat_f",
	"b_soldier_at_f",
	"b_soldier_lat_f",
	"b_g_soldier_lat_f",
	"o_soldieru_at_f",
	"o_soldieru_lat_f",
	"o_recon_lat_f",
	"b_ctrg_soldier_gl_lat_f",
	"b_recon_lat_f"
	];

RYD_WS_AAinf_class = 
	[
	"i_soldier_aa_f",
	"b_soldier_aa_f",
	"o_soldier_aa_f",
	"o_apc_tracked_02_aa_f",
	"b_apc_tracked_01_aa_f",
	"o_soldieru_aa_f"
	];

RYD_WS_Inf_class =
	[
	"i_crew_f",
	"i_engineer_f",
	"i_helicrew_f",
	"i_helipilot_f",
	"i_medic_f",
	"i_officer_f",
	"i_pilot_f",
	"i_soldier_a_f",
	"i_soldier_aa_f",
	"i_soldier_ar_f",
	"i_soldier_at_f",
	"i_soldier_exp_f",
	"i_soldier_f",
	"i_soldier_gl_f",
	"i_soldier_lat_f",
	"i_soldier_lite_f",
	"i_soldier_m_f",
	"i_soldier_repair_f",
	"i_soldier_sl_f",
	"i_soldier_tl_f",
	"i_soldier_uav_f",
	"o_crew_f",
	"o_engineer_f",
	"o_helicrew_f",
	"o_helipilot_f",
	"o_medic_f",
	"o_officer_f",
	"o_pilot_f",
	"o_soldier_a_f",
	"o_soldier_aa_f",
	"o_soldier_ar_f",
	"o_soldier_at_f",
	"o_soldier_exp_f",
	"o_soldier_f",
	"o_soldier_gl_f",
	"o_soldier_lat_f",
	"o_soldier_lite_f",
	"o_soldier_m_f",
	"o_soldier_pg_f",
	"o_soldier_repair_f",
	"o_soldier_sl_f",
	"o_soldier_tl_f",
	"o_soldier_uav_f",
	"b_g_engineer_f",
	"b_g_medic_f",
	"b_g_officer_f",
	"b_g_soldier_a_f",
	"b_g_soldier_ar_f",
	"b_g_soldier_exp_f",
	"b_g_soldier_f",
	"b_g_soldier_gl_f",
	"b_g_soldier_lat_f",
	"b_g_soldier_lite_f",
	"b_g_soldier_m_f",
	"b_g_soldier_sl_f",
	"b_g_soldier_tl_f",
	"b_g_survivor_f",
	"b_crew_f",
	"b_engineer_f",
	"b_helicrew_f",
	"b_helipilot_f",
	"b_medic_f",
	"b_officer_f",
	"b_pilot_f",
	"b_soldier_a_f",
	"b_soldier_aa_f",
	"b_soldier_ar_f",
	"b_soldier_at_f",
	"b_soldier_exp_f",
	"b_soldier_f",
	"b_soldier_gl_f",
	"b_soldier_lat_f",
	"b_soldier_lite_f",
	"b_soldier_m_f",
	"b_soldier_pg_f",
	"b_soldier_repair_f",
	"b_soldier_sl_f",
	"b_soldier_tl_f",
	"b_soldier_uav_f",
	"o_recon_exp_f",
	"o_recon_f",
	"o_recon_jtac_f",
	"o_recon_lat_f",
	"o_recon_m_f",
	"o_recon_medic_f",
	"o_recon_tl_f",
	"b_recon_exp_f",
	"b_recon_f",
	"b_recon_jtac_f",
	"b_recon_lat_f",
	"b_recon_m_f",
	"b_recon_medic_f",
	"b_recon_tl_f",
	"i_sniper_f",
	"i_spotter_f",
	"o_sniper_f",
	"o_spotter_f",
	"b_sniper_f",
	"b_spotter_f",
	"o_engineer_u_f",
	"o_soldieru_a_f",
	"o_soldieru_aa_f",
	"o_soldieru_aaa_f",
	"o_soldieru_aar_f",
	"o_soldieru_aat_f",
	"o_soldieru_ar_f",
	"o_soldieru_at_f",
	"o_soldieru_exp_f",
	"o_soldieru_f",
	"o_soldieru_gl_f",
	"o_soldieru_lat_f",
	"o_soldieru_m_f",
	"o_soldieru_medic_f",
	"o_soldieru_repair_f",
	"o_soldieru_sl_f",
	"o_soldieru_tl_f",
	"i_soldier_aaa_f",
	"i_soldier_aar_f",
	"i_soldier_aat_f",
	"i_support_amg_f",
	"i_support_amort_f",
	"i_support_gmg_f",
	"i_support_mg_f",
	"i_support_mort_f",
	"o_soldier_aaa_f",
	"o_soldier_aar_f",
	"o_soldier_aat_f",
	"o_support_amg_f",
	"o_support_amort_f",
	"o_support_gmg_f",
	"o_support_mg_f",
	"o_support_mort_f",
	"b_soldier_aaa_f",
	"b_soldier_aar_f",
	"b_soldier_aat_f",
	"b_support_amg_f",
	"b_support_amort_f",
	"b_support_gmg_f",
	"b_support_mg_f",
	"b_support_mort_f",
	"i_diver_exp_f",
	"i_diver_f",
	"i_diver_tl_f",
	"o_diver_exp_f",
	"o_diver_f",
	"o_diver_tl_f",
	"b_diver_exp_f",
	"b_diver_f",
	"b_diver_tl_f",
	"i_story_colonel_f",
	"o_story_ceo_f",
	"o_story_colonel_f",
	"i_g_story_protagonist_f",
	"b_competitor_f",
	"b_rangemaster_f",
	"b_story_colonel_f",
	"b_story_engineer_f",
	"b_story_pilot_f",
	"b_story_protagonist_f",
	"b_story_sf_captain_f",
	"b_story_tank_commander_f",
	"b_ctrg_soldier_engineer_exp_f",
	"b_ctrg_soldier_m_medic_f",
	"b_ctrg_soldier_ar_a_f",
	"b_ctrg_soldier_gl_lat_f",
	"i_g_story_sf_captain_f",
	"i_g_resistancecommander_f",
	"i_g_resistanceleader_f"
	];
	
RYD_WS_Art_class = 
	[
	"b_mbt_01_arty_f",
	"o_mbt_02_arty_f",
	"b_mbt_01_mlrs_f",
	"i_mortar_01_f",
	"o_mortar_01_f",
	"b_g_mortar_01_f",
	"b_mortar_01_f"
	];
	
RYD_WS_HArmor_class = 
	[
	"b_mbt_01_cannon_f",
	"b_mbt_01_tusk_f",
	"o_mbt_02_cannon_f",
	"i_mbt_03_cannon_f"
	];
	
RYD_WS_MArmor_class = 
	[
	];

RYD_WS_LArmor_class = 
	[
	"i_apc_wheeled_03_cannon_f",
	"o_apc_tracked_02_aa_f",
	"o_apc_tracked_02_cannon_f",
	"o_apc_wheeled_02_rcws_f",
	"b_apc_tracked_01_aa_f",
	"b_apc_tracked_01_rcws_f",
	"b_apc_wheeled_01_cannon_f",
	"i_apc_tracked_03_cannon_f"
	];
	
RYD_WS_LArmorAT_class =
	[
	"b_apc_wheeled_01_cannon_f",
	"i_apc_wheeled_03_cannon_f",
	"o_apc_tracked_02_cannon_f",
	"i_apc_tracked_03_cannon_f"
	];

RYD_WS_Cars_class =
	[
	"i_mrap_03_f",
	"i_mrap_03_gmg_f",
	"i_mrap_03_hmg_f",
	"i_quadbike_01_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f",
	"o_mrap_02_f",
	"o_mrap_02_gmg_f",
	"o_mrap_02_hmg_f",
	"o_quadbike_01_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_device_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f",
	"b_g_offroad_01_armed_f",
	"b_g_offroad_01_f",
	"b_g_quadbike_01_f",
	"b_g_van_01_transport_f",
	"b_g_offroad_01_repair_f",
	"b_mrap_01_f",
	"b_mrap_01_gmg_f",
	"b_mrap_01_hmg_f",
	"b_quadbike_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f",
	"i_truck_02_ammo_f",
	"i_truck_02_box_f",
	"i_truck_02_fuel_f",
	"i_truck_02_medical_f",
	"o_truck_02_ammo_f",
	"o_truck_02_box_f",
	"o_truck_02_fuel_f",
	"o_truck_02_medical_f",
	"b_g_van_01_fuel_f",
	"b_truck_01_ammo_f",
	"b_truck_01_repair_f",
	"b_truck_01_fuel_f",
	"b_truck_01_medical_f",
	"o_truck_03_ammo_f",
	"o_truck_03_fuel_f",
	"o_truck_03_medical_f",
	"o_truck_03_repair_f",
	"i_ugv_01_f",
	"i_ugv_01_rcws_f",
	"o_ugv_01_f",
	"o_ugv_01_rcws_f",
	"b_ugv_01_f",
	"b_ugv_01_rcws_f"
	];
	
RYD_WS_Air_class = 
	[
	"i_heli_transport_02_f",
	"i_plane_fighter_03_aa_f",
	"i_plane_fighter_03_cas_f",
	"b_plane_cas_01_f",
	"o_plane_cas_02_f",
	"o_heli_attack_02_black_f",
	"o_heli_attack_02_f",
	"o_heli_light_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_attack_01_f",
	"b_heli_light_01_armed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_uav_ai",
	"o_uav_ai",
	"b_uav_ai",
	"i_uav_01_f",
	"i_uav_02_cas_f",
	"i_uav_02_f",
	"o_uav_01_f",
	"o_uav_02_cas_f",
	"o_uav_02_f",
	"b_uav_01_f",
	"b_uav_02_cas_f",
	"b_uav_02_f",
	"i_heli_light_03_f",
	"i_heli_light_03_unarmed_f"
	];
	
RYD_WS_Air_class_B = 
	[
	//"b_plane_cas_01_f",
	"b_heli_attack_01_f",
	"b_heli_light_01_armed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f"
	];
	
RYD_WS_Air_class_O = 
	[
	//"o_plane_cas_02_f",
	"o_heli_attack_02_black_f",
	"o_heli_attack_02_f",
	"o_heli_light_02_f",
	"o_heli_light_02_unarmed_f"
	];
	
RYD_WS_Air_class_I = 
	[
	"i_heli_transport_02_f",
	//"i_plane_fighter_03_aa_f",
	//"i_plane_fighter_03_cas_f",
	"i_heli_light_03_f",
	"i_heli_light_03_unarmed_f"
	];
	
RYD_WS_BAir_class = 
	[
	"i_plane_fighter_03_cas_f",
	"b_plane_cas_01_f",
	"o_plane_cas_02_f"
	];
	
RYD_WS_RAir_class = 
	[
	"i_uav_01_f",
	"i_uav_02_cas_f",
	"i_uav_02_f",
	"o_uav_01_f",
	"o_uav_02_cas_f",
	"o_uav_02_f",
	"b_uav_01_f",
	"b_uav_02_cas_f",
	"b_uav_02_f"
	];
	
RYD_WS_NCAir_class = 
	[
	"i_heli_transport_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_heli_light_03_unarmed_f",
	"i_uav_01_f",
	"i_uav_02_f",
	"o_uav_01_f",
	"o_uav_02_f",
	"b_uav_01_f",
	"b_uav_02_f"	
	];

RYD_WS_Naval_class = 
	[
	"i_boat_armed_01_minigun_f",
	"i_boat_transport_01_f",
	"o_boat_armed_01_hmg_f",
	"o_boat_transport_01_f",
	"o_lifeboat",
	"b_g_boat_transport_01_f",
	"b_boat_armed_01_minigun_f",
	"b_boat_transport_01_f",
	"b_lifeboat",
	"i_sdv_01_f",
	"o_sdv_01_f",
	"b_sdv_01_f"	
	];
	
RYD_WS_Static_class = 
	[
	"i_gmg_01_a_f",
	"i_gmg_01_f",
	"i_gmg_01_high_f",
	"i_hmg_01_a_f",
	"i_hmg_01_f",
	"i_hmg_01_high_f",
	"i_mortar_01_f",
	"i_static_aa_f",
	"i_static_at_f",
	"o_gmg_01_a_f",
	"o_gmg_01_f",
	"o_gmg_01_high_f",
	"o_hmg_01_a_f",
	"o_hmg_01_f",
	"o_hmg_01_high_f",
	"o_mortar_01_f",
	"o_static_aa_f",
	"o_static_at_f",
	"b_g_mortar_01_f",
	"b_gmg_01_a_f",
	"b_gmg_01_f",
	"b_gmg_01_high_f",
	"b_hmg_01_a_f",
	"b_hmg_01_f",
	"b_hmg_01_high_f",
	"b_mortar_01_f",
	"b_static_aa_f",
	"b_static_at_f"
	];
	
RYD_WS_Static_class_B = 
	[
	"b_g_mortar_01_f",
	"b_gmg_01_a_f",
	"b_gmg_01_f",
	"b_gmg_01_high_f",
	"b_hmg_01_a_f",
	"b_hmg_01_f",
	"b_hmg_01_high_f",
	"b_mortar_01_f",
	"b_static_aa_f",
	"b_static_at_f"
	];
	
RYD_WS_Static_class_O = 
	[
	"o_gmg_01_a_f",
	"o_gmg_01_f",
	"o_gmg_01_high_f",
	"o_hmg_01_a_f",
	"o_hmg_01_f",
	"o_hmg_01_high_f",
	"o_mortar_01_f",
	"o_static_aa_f",
	"o_static_at_f"
	];
	
RYD_WS_Static_class_I = 
	[
	"i_gmg_01_a_f",
	"i_gmg_01_f",
	"i_gmg_01_high_f",
	"i_hmg_01_a_f",
	"i_hmg_01_f",
	"i_hmg_01_high_f",
	"i_mortar_01_f",
	"i_static_aa_f",
	"i_static_at_f"
	];
	
RYD_WS_StaticAA_class =
	[
	"i_static_aa_f",
	"o_static_aa_f",
	"b_static_aa_f"
	];
	
RYD_WS_StaticAT_class =
	[
	"i_static_at_f",
	"o_static_at_f",
	"b_static_at_f"
	];
	
RYD_WS_Support_class =
	[
	"i_truck_02_ammo_f",
	"i_truck_02_box_f",
	"i_truck_02_fuel_f",
	"i_truck_02_medical_f",
	"o_truck_02_ammo_f",
	"o_truck_02_box_f",
	"o_truck_02_fuel_f",
	"o_truck_02_medical_f",
	"o_truck_03_ammo_f",
	"o_truck_03_fuel_f",
	"o_truck_03_medical_f",
	"o_truck_03_repair_f",
	"b_g_van_01_fuel_f",
	"b_g_offroad_01_repair_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_ammo_f",
	"b_truck_01_repair_f",
	"b_truck_01_fuel_f",
	"b_truck_01_medical_f"
	];
	
RYD_WS_Support_class_B =
	[
	"b_g_van_01_fuel_f",
	"b_g_offroad_01_repair_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_ammo_f",
	"b_truck_01_repair_f",
	"b_truck_01_fuel_f",
	"b_truck_01_medical_f"
	];
	
RYD_WS_Support_class_O =
	[
	"o_truck_02_ammo_f",
	"o_truck_02_box_f",
	"o_truck_02_fuel_f",
	"o_truck_02_medical_f",
	"o_truck_03_ammo_f",
	"o_truck_03_fuel_f",
	"o_truck_03_medical_f",
	"o_truck_03_repair_f"
	];
	
RYD_WS_Support_class_I =
	[
	"i_truck_02_ammo_f",
	"i_truck_02_box_f",
	"i_truck_02_fuel_f",
	"i_truck_02_medical_f"
	];
	
RYD_WS_Cargo_class =
	[
	"i_heli_transport_02_f",
	"o_heli_attack_02_black_f",
	"o_heli_attack_02_f",
	"o_heli_light_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_truck_02_medical_f",
	"o_truck_02_medical_f",
	"b_truck_01_medical_f",
	"o_truck_03_medical_f",
	"i_boat_armed_01_minigun_f",
	"i_boat_transport_01_f",
	"o_boat_armed_01_hmg_f",
	"o_boat_transport_01_f",
	"o_lifeboat",
	"b_g_boat_transport_01_f",
	"b_boat_armed_01_minigun_f",
	"b_boat_transport_01_f",
	"b_lifeboat",
	"i_sdv_01_f",
	"o_sdv_01_f",
	"b_sdv_01_f",
	"b_mbt_01_cannon_f",
	"i_apc_wheeled_03_cannon_f",
	"o_apc_tracked_02_cannon_f",
	"o_apc_wheeled_02_rcws_f",
	"b_apc_tracked_01_rcws_f",
	"b_apc_wheeled_01_cannon_f",
	"i_mrap_03_f",
	"i_mrap_03_gmg_f",
	"i_mrap_03_hmg_f",
	"i_quadbike_01_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f",
	"o_mrap_02_f",
	"o_mrap_02_gmg_f",
	"o_mrap_02_hmg_f",
	"o_quadbike_01_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_device_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f",
	"b_g_offroad_01_armed_f",
	"b_g_offroad_01_f",
	"b_g_quadbike_01_f",
	"b_g_van_01_transport_f",
	"b_mrap_01_f",
	"b_mrap_01_gmg_f",
	"b_mrap_01_hmg_f",
	"b_quadbike_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f",
	"i_heli_light_03_f",
	"i_heli_light_03_unarmed_f",
	"i_apc_tracked_03_cannon_f"	
	];
	
RYD_WS_NCCargo_class = 
	[
	"i_heli_transport_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_heli_light_03_unarmed_f",
	"i_truck_02_medical_f",
	"o_truck_02_medical_f",
	"b_truck_01_medical_f",
	"o_truck_03_medical_f",
	"i_boat_transport_01_f",
	"o_boat_transport_01_f",
	"o_lifeboat",
	"b_g_boat_transport_01_f",
	"b_boat_transport_01_f",
	"b_lifeboat",
	"i_mrap_03_f",
	"i_quadbike_01_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f",
	"o_mrap_02_f",
	"o_quadbike_01_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_device_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f",
	"b_g_offroad_01_f",
	"b_g_quadbike_01_f",
	"b_g_van_01_transport_f",
	"b_mrap_01_f",
	"b_quadbike_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f"	
	];
	
RYD_WS_NCCargo_class_B = 
	[
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"b_g_offroad_01_f",
	"b_g_van_01_transport_f",
	"b_mrap_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f"	
	];
	
RYD_WS_NCCargo_class_I = 
	[
	"i_heli_transport_02_f",
	"i_heli_light_03_unarmed_f",
	"i_mrap_03_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f"	
	];
	
RYD_WS_NCCargo_class_O = 
	[
	"o_heli_light_02_unarmed_f",
	"o_mrap_02_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f"	
	];
	
RYD_WS_Crew_class =
	[
	"i_crew_f",
	"i_helicrew_f",
	"i_helipilot_f",
	"i_pilot_f",
	"o_crew_f",
	"o_helicrew_f",
	"o_helipilot_f",
	"o_pilot_f",
	"b_crew_f",
	"b_helicrew_f",
	"b_helipilot_f",
	"b_pilot_f",
	"b_story_pilot_f"
	];
	
RYD_WS_Other_class = 
	[
	"i_uav_ai",
	"o_uav_ai",
	"b_uav_ai"	
	];
	
RYD_WS_rep =
	[
	"o_truck_03_repair_f",
	"i_truck_02_box_f",
	"o_truck_02_box_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_repair_f",
	"b_g_offroad_01_repair_f"
	];
	
RYD_WS_med = 
	[
	"o_truck_03_medical_f",
	"i_truck_02_medical_f",
	"o_truck_02_medical_f",
	"b_truck_01_medical_f"
	];
	
RYD_WS_fuel =
	[
	"o_truck_03_fuel_f",
	"i_truck_02_fuel_f",
	"o_truck_02_fuel_f",
	"b_g_van_01_fuel_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_fuel_f"
	];
	
RYD_WS_ammo = 
	[
	"o_truck_03_ammo_f",
	"i_truck_02_ammo_f",
	"o_truck_02_ammo_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_ammo_f"
	];
	
RYD_WS_AllClasses = RYD_WS_Inf_class + RYD_WS_Art_class + RYD_WS_HArmor_class + RYD_WS_MArmor_class + RYD_WS_LArmor_class + RYD_WS_Cars_class + RYD_WS_Air_class + RYD_WS_Naval_class + RYD_WS_Static_class + RYD_WS_Support_class + RYD_WS_Other_class;			
	
RHQ_SpecFor = [];
RHQ_Recon = [];
RHQ_FO = [];
RHQ_Snipers = [];
RHQ_ATInf = [];
RHQ_AAInf = [];
RHQ_Inf = [];
RHQ_Art = [];
RHQ_HArmor = [];
RHQ_LArmor = [];
RHQ_LArmorAT = [];
RHQ_Cars = [];
RHQ_Air = [];
RHQ_NCAir = [];
RHQ_Naval = [];
RHQ_Static = [];
RHQ_StaticAA = [];
RHQ_StaticAT = [];
RHQ_Support = [];
RHQ_Cargo = [];
RHQ_NCCargo = [];
RHQ_Other = [];
RHQ_Crew = [];
RHQ_MArmor = [];
RHQ_BAir = [];
RHQ_RAir = [];
RHQ_Ammo = [];
RHQ_Fuel = [];
RHQ_Med = [];
RHQ_Rep = [];

RYD_WS_B_Infantry_G = [];
RYD_WS_B_Motorized_G = [];
RYD_WS_B_Mechanized_G = [];
RYD_WS_B_Armored_G = [];
RYD_WS_B_Air_G = [];
RYD_WS_B_Air_G2 = [];
RYD_WS_B_Static_G2 = [];
RYD_WS_B_Support_G2 = [];
RYD_WS_B_NCCargo_G2 = [];
RYD_WS_B_Officers_G2 = [];

RYD_WS_I_Infantry_G = [];
RYD_WS_I_Motorized_G = [];
RYD_WS_I_Mechanized_G = [];
RYD_WS_I_Armored_G = [];
RYD_WS_I_Air_G = [];
RYD_WS_I_Air_G2 = [];
RYD_WS_I_Static_G2 = [];
RYD_WS_I_Support_G2 = [];
RYD_WS_I_NCCargo_G2 = [];
RYD_WS_I_Officers_G2 = [];

RYD_WS_O_Infantry_G = [];
RYD_WS_O_Motorized_G = [];
RYD_WS_O_Mechanized_G = [];
RYD_WS_O_Armored_G = [];
RYD_WS_O_Air_G = [];
RYD_WS_O_Air_G2 = [];
RYD_WS_O_Static_G2 = [];
RYD_WS_O_Support_G2 = [];
RYD_WS_O_NCCargo_G2 = [];
RYD_WS_O_Officers_G2 = [];

RydHQ_Add_OtherArty = [];

RYD_WS_DynamicRHQ = 
	{
	_gpClass = configFile >> "CfgGroups";
	_vehClass = configFile >> "CfgVehicles";
	
	_aFactions = [];
	
		{
		_aFactions pushBack ((_x select 0) select 0)
		}
	foreach RYD_WS_selFactionsA;
	
	
	_bFactions = [];
	
		{
		_bFactions pushBack ((_x select 0) select 0)
		}
	foreach RYD_WS_selFactionsB;
	
	RYD_WS_SelectedFactions = _aFactions + _bFactions;

	for "_i" from 0 to ((count _gpClass) - 1) do
		{
		_class = _gpClass select _i;
		
		if (isClass _class) then
			{
			_side = configName _class;
			_rSide = east;
			
			switch (toLower _side) do
				{
				case ("east") : {_rSide = east};
				case ("west") : {_rSide = west};
				case ("indep") : {_rSide = resistance};
				default {_rSide = civilian};
				};
				
			if (_rSide == civilian) exitWith {};	

			_path = _gpClass >> _side;
			
			for "_j" from 0 to ((count _path) - 1) do
				{
				_class = _path select _j;
				
				if (isClass _class) then
					{
					_fc = configName _class;
					_myFac = _fc;
					
					_path2 = _path >> _fc;
					
					for "_k" from 0 to ((count _path2) - 1) do
						{
						_class = _path2 select _k;
				
						if (isClass _class) then
							{
							_kind = configName _class;
							
							_path3 = _path2 >> _kind;
							
							for "_l" from 0 to ((count _path3) - 1) do
								{
								_class = _path3 select _l;
								
								if (isClass _class) then
									{
									_gp = configName _class;
									
									_path4 = _path3 >> _gp;
									
									_name = getText (_path4 >> "name");
									if ((toLower _name) in ["diver team"]) exitWith {};
									
									_cnt = count _path4;
									_gpType = "inf";
									_typeC = false;
									_vehs = [];
									_isArty = false;
									
									for "_m" from 0 to (_cnt - 1) do
										{
										_type = "inf";
										_class = _path4 select _m;
										
										if (isClass _class) then
											{
											_unit = configName _class;
											
											_veh = _path4 >> _unit >> "vehicle";
											
											if (isText _veh) then
												{
												_veh = toLower (getText _veh);
												_base = _veh;
												_wrong = false;
												
												while {not (_base in ["air","ship","tank","car","wheeled_apc_f","ugv_01_base_f"])} do
													{
													_base = inheritsFrom (_vehClass >> _base);
													if not (isClass _base) exitWith {};
													_base = toLower (configName _base);
													if (_base in ["allvehicles","all"]) exitWith {};
													};

												if (_base in ["ugv_01_base_f"]) then {_wrong = true;_gpType = "ugv_01_base_f"};
													
												if not (_wrong) then
													{
													if (_base in ["air","ship","tank","car","wheeled_apc_f"]) then
														{
														_type = _base
														};
														
													if not (_typeC) then
														{
														if not (_type in ["inf"]) then
															{
															_gpType = _type;
															_typeC = true
															}
														};
														
													_vehClass2 = configfile >> "CfgVehicles" >> _veh;
													
													_myFac = getText (_vehClass2 >> "faction");
														
													if ((getNumber (_vehClass2 >> "artilleryScanner")) > 0) then
														{
														_isArty = true
														};
														
													if not (_veh in RYD_WS_AllClasses) then
														{
														RYD_WS_AllClasses set [(count RYD_WS_AllClasses),_veh];
														
														_turrets = _vehClass2 >> "Turrets";
														
														switch (_type) do
															{
															case ("inf") : 
																{
																RHQ_Inf set [(count RHQ_Inf),_veh];

																if ((getNumber (_vehClass2 >> "camouflage")) < 1) then
																	{
																	if ((toLower (getText (_vehClass2 >> "textSingular"))) in ["sniper"]) then
																		{
																		RHQ_Snipers set [(count RHQ_Snipers),_veh]
																		}
																	else
																		{
																		_weapons = getArray (_vehClass2 >> "weapons");
																		
																		RHQ_Recon set [(count RHQ_Recon),_veh];
																		
																		_hasLaserD = false;
																		
																			{
																			_wpClass = configFile >> "CfgWeapons" >> _x;
																			_type = getNumber (_wpClass >> "type");
																			
																			if (_type == 4096) then
																				{
																				_cursor = toLower (getText (_wpClass >> "cursor"));
																				if (_cursor in ["","emptycursor"]) then 
																					{
																					_cursor = toLower (getText (_wpClass >> "cursorAim"))
																					};

																				if (_cursor in ["laserdesignator"]) exitWith {_hasLaserD = true}
																				};
																				
																			if (_hasLaserD) exitWith {}
																			}
																		foreach _weapons;
																		
																		if (_hasLaserD) then
																			{
																			RHQ_FO set [(count RHQ_FO),_veh]
																			}
																		}
																	};
																	
																if ((toLower ((getText (_vehClass2 >> "textSingular")))) in ["at soldier"]) then
																	{
																	_isAT = true;
																	_weaponsArr = if (isArray (_vehClass2 >> "Weapons")) then
																		{
																		getArray (_vehClass2 >> "Weapons")
																		}
																	else
																		{
																		[]
																		};
																
																	_weaponsArr =	_weaponsArr - ["Throw","Put"];
																	
																	if ((count _weaponsArr) > 1) then
																		{
																		_sWeapon = _weaponsArr select 1;
																		if (isArray (configfile >> "CfgWeapons" >> _sWeapon >> "magazines")) then
																			{
																			_mags = (getArray (configfile >> "CfgWeapons" >> _sWeapon >> "magazines"));
																			if ((count _mags) > 0) then
																				{
																				_mag = (_mags select 0);
																				
																				if (isText (configfile >> "CfgMagazines" >> _mag >> "ammo")) then
																					{
																					_ammo = getText (configfile >> "CfgMagazines" >> _mag >> "ammo");
																					
																					if (isNumber (configfile >> "CfgAmmo" >> _ammo >> "airLock")) then
																						{
																						_isAT = (getNumber (configfile >> "CfgAmmo" >> _ammo >> "airLock")) < 1;
																						}
																					};
																				};
																			};
																		};
																	
																	if (_isAT) then 
																		{
																		RHQ_ATInf set [(count RHQ_ATInf),_veh]
																		} 
																	else 
																		{
																		RHQ_AAInf set [(count RHQ_AAInf),_veh]
																		};
																	
																	}
																};
																
															case ("car") : {RHQ_Cars set [(count RHQ_Cars),_veh]};	
															case ("tank") : {RHQ_HArmor set [(count RHQ_HArmor),_veh]};	
															case ("wheeled_apc_f") : {RHQ_LArmor set [(count RHQ_LArmor),_veh]};
															case ("air") : 
																{
																RHQ_Air set [(count RHQ_Air),_veh];
																if ((((count _turrets) + (count ((getArray (_vehClass2 >> "Weapons")) - ["CMFlareLauncher"]))) < 1)) then
																	{
																	RHQ_NCAir set [(count RHQ_NCAir),_veh];
																	};
																	
																_isUAV = (getNumber (_vehClass2 >> "Uav")) > 0;
																	
																if (_isUAV) then
																	{
																	RHQ_RAir set [(count RHQ_RAir),_veh]
																	}
																};
																
															case ("ship") : {RHQ_Naval set [(count RHQ_Naval),_veh]};
															};
															
														if not (_type in ["inf"]) then
															{
															_vehs set [(count _vehs),_veh];
															
															_mainT = _turrets >> "MainTurret";
															_isMainT = isClass _mainT;

															if ((getNumber (_vehClass2 >> "transportSoldier")) > 0) then 
																{
																RHQ_Cargo set [(count RHQ_Cargo),_veh];
																if not (_isMainT) then
																	{
																	RHQ_NCCargo set [(count RHQ_NCCargo),_veh];
																	}
																};
																
															if ((getNumber (_vehClass2 >> "artilleryScanner")) > 0) then
																{
																RHQ_Art set [(count RHQ_Art),_veh];
																
																_prim = "";
																_rare = "";
																_sec = "";
																_smoke = "";
																_illum = "";

																if (_isMainT) then
																	{
																	_mags = getArray (_mainT >> "magazines");
																	_maxHit = 10;
																	
																		{
																		_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																		_ammoC = configfile >> "CfgAmmo" >> _ammo;
																		
																		_actHit = getNumber (_ammoC >> "indirectHit");
																		
																		if (_actHit > _maxHit) then
																			{
																			_maxHit = _actHit;
																			_prim = _x
																			}
																		}
																	foreach _mags;
																	
																	_mags = _mags - [_prim];
																	_mags0 = +_mags;
																	_illumChosen = false;
																	_smokeChosen = false;
																	_rareChosen = false;
																	_secChosen = false;
																	
																		{
																		_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																		_ammoC = configfile >> "CfgAmmo" >> _ammo;
																		
																		_hit = getNumber (_ammoC >> "indirectHit");
																		_lc = _ammoC >> "lightColor";
																		_sim = toLower (getText (_ammoC >> "simulation"));
																		_subM = toLower (getText (_ammoC >> "submunitionAmmo"));
																		
																		if (_hit <= 10) then
																			{
																			if not (_subM in [""]) then
																				{
																				_ammoC = configfile >> "CfgAmmo" >> _subM;
																				_hit = getNumber (_ammoC >> "indirectHit")
																				}
																			};

																		switch (true) do
																			{
																			case ((isArray _lc) and not (_illumChosen)) : 
																				{
																				_illum = _x;
																				_mags = _mags - [_x];
																				_illumChosen = true
																				};
																				
																			case ((_hit <= 10) and (_subM in ["smokeshellarty"]) and not (_smokeChosen)) : 
																				{
																				_smoke = _x;
																				_mags = _mags - [_x];
																				_smokeChosen = true
																				};
																				
																			case ((_sim in ["shotsubmunitions"]) and not (_rareChosen)) : 
																				{
																				_rare = _x;
																				_mags = _mags - [_x];
																				_rareChosen = true
																				};
																				
																			case ((_hit > 10) and not ((_secChosen) or (_rare == _x)))  : 
																				{
																				_sec = _x;
																				_mags = _mags - [_x];
																				_secChosen = true
																				}
																			}
																		}
																	foreach _mags0;
																	
																	if (_sec in [""]) then
																		{
																		_maxHit = 10;
																		
																			{
																			_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																			_ammoC = configfile >> "CfgAmmo" >> _ammo;
																			_subAmmo = _ammoC >> "subMunitionAmmo";

																			if ((isText _subAmmo) and {not ((getText _subAmmo) in [""])}) then
																				{
																				_ammoC = configfile >> "CfgAmmo" >> (getText _subAmmo);
																				};
																				
																			_actHit = getNumber (_ammoC >> "indirectHit");
																			
																			if (_actHit > _maxHit) then
																				{
																				_maxHit = _actHit;
																				_sec = _x
																				}
																			}
																		foreach _mags;
																		}
																	};
																	
																_arr = [_prim,_rare,_sec,_smoke,_illum];
																if (({_x in [""]} count _arr) < 5) then
																	{
																	RydHQ_Add_OtherArty set [(count RydHQ_Add_OtherArty),[[_veh],_arr]]
																	}
																};
																
															RHQ_HArmor = RHQ_HArmor - RHQ_Art;

															if (_isMainT) then
																{
																_mags = getArray (_mainT >> "magazines");
																
																	{
																	_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																	_ammoC = configfile >> "CfgAmmo" >> _ammo;
																	
																	_isAA = (getNumber (_ammoC >> "airLock")) > 1;
																	_isAT = ((((getNumber (_ammoC >> "irLock")) + (getNumber (_ammoC >> "laserLock"))) > 0) and ((getNumber (_ammoC >> "airLock")) < 2));
																	
																	if (_isAA) then {RHQ_AAInf set [(count RHQ_AAInf),_veh]};
																	if (_isAT) then 
																		{
																		if (_type in ["wheeled_apc_f"]) then
																			{
																			RHQ_LArmorAT set [(count RHQ_LArmorAT),_veh]
																			}
																		else
																			{
																			if (_type in ["car"]) then
																				{
																				RHQ_ATInf set [(count RHQ_ATInf),_veh]
																				}
																			}
																		};
																		
																	if ((_isAA) or (_isAT)) exitWith {}
																	}
																foreach _mags
																}
															}
														}	
													}
												}
											}
										};
																				
										{
										_crew = _vehClass >> _x >> "crew";
										
										if (isText _crew) then
											{
											_crew = toLower (getText _crew);

											if not (_crew in (RYD_WS_Inf_class + RHQ_Inf)) then
												{
												RYD_WS_AllClasses set [(count RYD_WS_AllClasses),_crew];
												RHQ_Inf set [(count RHQ_Inf),_crew];
												RHQ_Crew set [(count RHQ_Crew),_crew];
												}
											}
										}
									foreach _vehs;
									
									RHQ_Inf = RHQ_Inf - ["b_uav_ai","i_uav_ai","o_uav_ai"];
									RHQ_Crew = RHQ_Crew - ["b_uav_ai","i_uav_ai","o_uav_ai"];
									
									//diag_log format ["[_rSide,_path4,_isArty,_name]: %1 typ: %2",[_rSide,_path4,_isArty,_name],_gpType];
									
									if not (_gpType in ["air","ship","ugv_01_base_f"]) then
										{
										_fac = _myFac;
										if ((toLower _fac) in ["guerilla"]) then {_fac = "blu_g_f"};
										//diag_log format ["chosen: %1,this: %2",RYD_WS_SelectedFactions,(toLower _fac)];
										if not ((toLower _fac) in RYD_WS_SelectedFactions) exitWith {};
										
										_gp = [_rSide,_path4,_isArty,_name];
										
										//diag_log format ["gp: %1",_gp];
											
										switch (true) do
											{
											case (_gpType in ["tank"]) : 
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Armored_G + RYD_WS_I_Armored_G + RYD_WS_O_Armored_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Armored_G set [(count RYD_WS_B_Armored_G),_gp]};
														case (resistance) : {RYD_WS_I_Armored_G set [(count RYD_WS_I_Armored_G),_gp]};
														case (east) : {RYD_WS_O_Armored_G set [(count RYD_WS_O_Armored_G),_gp]};
														}
													}
												};
												
											case (_gpType in ["wheeled_apc_f"]) : 
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Mechanized_G + RYD_WS_I_Mechanized_G + RYD_WS_O_Mechanized_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Mechanized_G set [(count RYD_WS_B_Mechanized_G),_gp]};
														case (resistance) : {RYD_WS_I_Mechanized_G set [(count RYD_WS_I_Mechanized_G),_gp]};
														case (east) : {RYD_WS_O_Mechanized_G set [(count RYD_WS_O_Mechanized_G),_gp]};
														}
													}
												};
												
											case (_gpType in ["car"]) : 
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Motorized_G + RYD_WS_I_Motorized_G + RYD_WS_O_Motorized_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Motorized_G set [(count RYD_WS_B_Motorized_G),_gp]};
														case (resistance) : {RYD_WS_I_Motorized_G set [(count RYD_WS_I_Motorized_G),_gp]};
														case (east) : {RYD_WS_O_Motorized_G set [(count RYD_WS_O_Motorized_G),_gp]};
														}
													}
												};
												
											default
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Infantry_G + RYD_WS_I_Infantry_G + RYD_WS_O_Infantry_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Infantry_G set [(count RYD_WS_B_Infantry_G),_gp]};
														case (resistance) : {RYD_WS_I_Infantry_G set [(count RYD_WS_I_Infantry_G),_gp]};
														case (east) : {RYD_WS_O_Infantry_G set [(count RYD_WS_O_Infantry_G),_gp]};
														}
													}										
												}
											}										
										}
									}
								}
							}
						}
					}
				}
			}
		};
				
	for "_i" from 0 to ((count _vehClass) - 1) do
		{
		_class = _vehClass select _i;
		
		if (isClass _class) then
			{
			_class = toLower (configName _class);

			if not (_class isKindOf "ugv_01_base_f") then
				{
				if not (_class in (RYD_WS_Art_class + RYD_WS_Static_class + RYD_WS_Support_class + RYD_WS_NCCargo_class)) then
					{
					_scope = getNumber (_vehClass >> _class >> "Scope");
					if (_scope == 2) then
						{
						_vehClass2 = _vehClass >> _class;
						_side = getNumber (_vehClass2 >> "side");
						_hasD = (getNumber (_vehClass2 >> "hasDriver")) > 0;
						_isCargo = (getNumber (_vehClass2 >> "transportSoldier")) > 0;
						_sim = toLower (getText (_vehClass2 >> "simulation"));
						
						_turrets = _vehClass2 >> "Turrets";
						_mainT = _turrets >> "MainTurret";
						_isMainT = isClass _mainT;
						_crew = toLower (getText (_vehClass2 >> "crew"));
						_isAI = not ((_crew find "uav_ai") isEqualTo -1);
						
						if ((_side in [0,1,2]) and {not (_isAI)}) then
							{
							_fac = toLower (getText (_vehClass2 >> "faction"));
							
							if not (_hasD) then
								{													
								if (_isMainT) then
									{
									RHQ_Static set [(count RHQ_Static),_class];
									
									if (_fac in RYD_WS_SelectedFactions) then
										{
										switch (_side) do
											{
											case (0) : {RYD_WS_O_Static_G2 set [(count RYD_WS_O_Static_G2),_class]};
											case (1) : {RYD_WS_B_Static_G2 set [(count RYD_WS_B_Static_G2),_class]};
											case (2) : {RYD_WS_I_Static_G2 set [(count RYD_WS_I_Static_G2),_class]};
											}
										};
									
									_mags = getArray (_mainT >> "magazines");
									
										{
										_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
										_ammoC = configfile >> "CfgAmmo" >> _ammo;
										
										_isAA = (getNumber (_ammoC >> "airLock")) > 1;
										_isAT = ((((getNumber (_ammoC >> "irLock")) + (getNumber (_ammoC >> "laserLock"))) > 0) and ((getNumber (_ammoC >> "airLock")) < 2));
										
										if (_isAA) then {RHQ_StaticAA set [(count RHQ_StaticAA),_class]};
										if (_isAT) then {RHQ_StaticAT set [(count RHQ_StaticAT),_class]};
											
										if ((_isAA) or (_isAT)) exitWith {}
										}
									foreach _mags;
									
									if ((getNumber (_vehClass2 >> "artilleryScanner")) > 0) then
										{
										RHQ_Art set [(count RHQ_Art),_class];
										
										_prim = "";
										_rare = "";
										_sec = "";
										_smoke = "";
										_illum = "";

										if (_isMainT) then
											{
											_mags = getArray (_mainT >> "magazines");
											_maxHit = 10;
											
												{
												_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
												_ammoC = configfile >> "CfgAmmo" >> _ammo;
												
												_actHit = getNumber (_ammoC >> "hit");
												
												if (_actHit > _maxHit) then
													{
													_maxHit = _actHit;
													_prim = _x
													}
												}
											foreach _mags;
											
											_mags = _mags - [_prim];
											_mags0 = +_mags;
											_illumChosen = false;
											_smokeChosen = false;
											_rareChosen = false;
											_secChosen = false;
											
												{
												_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
												_ammoC = configfile >> "CfgAmmo" >> _ammo;
												
												_hit = getNumber (_ammoC >> "hit");
												_lc = _ammoC >> "lightColor";
												_sim = toLower (getText (_ammoC >> "simulation"));
												_subM = toLower (getText (_ammoC >> "submunitionAmmo"));
												
												if (_hit <= 10) then
													{
													if not (_subM in [""]) then
														{
														_ammoC = configfile >> "CfgAmmo" >> _subM;
														_hit = getNumber (_ammoC >> "hit")
														}
													};

												switch (true) do
													{
													case ((isArray _lc) and not (_illumChosen)) : 
														{
														_illum = _x;
														_mags = _mags - [_x];
														_illumChosen = true
														};
														
													case ((_hit <= 10) and (_subM in ["smokeshellarty"]) and not (_smokeChosen)) : 
														{
														_smoke = _x;
														_mags = _mags - [_x];
														_smokeChosen = true
														};
														
													case ((_sim in ["shotsubmunitions"]) and not (_rareChosen)) : 
														{
														_rare = _x;
														_mags = _mags - [_x];
														_rareChosen = true
														};
														
													case ((_hit > 10) and not ((_secChosen) or (_rare == _x)))  : 
														{
														_sec = _x;
														_mags = _mags - [_x];
														_secChosen = true
														}
													}
												}
											foreach _mags0;
											
											if (_sec in [""]) then
												{
												_maxHit = 10;
												
													{
													_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
													_ammoC = configfile >> "CfgAmmo" >> _ammo;
													_subAmmo = _ammoC >> "subMunitionAmmo";
													
													if ((isText _subAmmo) and {not ((getText _subAmmo) in [""])}) then
														{
														_ammoC = configfile >> "CfgAmmo" >> (getText _subAmmo);
														};
														
													_actHit = getNumber (_ammoC >> "hit");
													
													if (_actHit > _maxHit) then
														{
														_maxHit = _actHit;
														_sec = _x
														}
													}
												foreach _mags;
												}
											};
											
										_arr = [_prim,_rare,_sec,_smoke,_illum];
										if (({_x in [""]} count _arr) < 5) then
											{
											RydHQ_Add_OtherArty set [(count RydHQ_Add_OtherArty),[[_class],_arr]]
											}
										}
									}
								}
							else
								{
								_isMan = isNumber (_vehClass2 >> "isMan");
								
								if (_isMan) then
									{
									_isMan = (getNumber (_vehClass2 >> "isMan")) > 0;
									};
								
								if not (_isMan) then
									{
									_isAmmoS = (getNumber (_vehClass2 >> "transportAmmo")) > 0;
									_isFuelS = (getNumber (_vehClass2 >> "transportFuel")) > 0;
									_isRepS = (getNumber (_vehClass2 >> "transportRepair")) > 0;
									_isMedS = (getNumber (_vehClass2 >> "attendant")) > 0;
									
									if (_isAmmoS) then 
										{
										RHQ_Ammo set [(count RHQ_Ammo),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_isFuelS) then 
										{
										RHQ_Fuel set [(count RHQ_Fuel),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_isRepS) then 
										{
										RHQ_Rep set [(count RHQ_Rep),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_isMedS) then 
										{
										RHQ_Med set [(count RHQ_Med),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_class in RHQ_Support) then
										{
										_side = getNumber (_vehClass2 >> "side");

										if (_fac in RYD_WS_SelectedFactions) then
											{
											switch (_side) do
												{
												case (0) : {RYD_WS_O_Support_G2 set [(count RYD_WS_O_Support_G2),_class]};
												case (1) : {RYD_WS_B_Support_G2 set [(count RYD_WS_B_Support_G2),_class]};
												case (2) : {RYD_WS_I_Support_G2 set [(count RYD_WS_I_Support_G2),_class]};
												}
											};
										};
										
									if not (_class in (RYD_WS_Air_class + RHQ_Air)) then	
										{
										_base = _class;
										
										while {not (_base in ["air"])} do
											{
											_base = inheritsFrom (_vehClass >> _base);
											if not (isClass _base) exitWith {};
											_base = toLower (configName _base);
											if (_base in ["allvehicles","all"]) exitWith {};
											};
										
										if (_base in ["air"]) then 
											{
											_isChopper = _sim in ["helicopterx","helicopterrtd"];
											
											_isUAV = if (isNumber (_vehClass2 >> "Uav")) then
												{
												((getNumber (_vehClass2 >> "Uav")) > 0)
												}
											else
												{
												false
												};

											if (_isChopper) then
												{
												_mainT = _turrets >> "MainTurret";
												_isMainT = isClass _mainT;
												
												if ((getNumber (_vehClass2 >> "transportSoldier")) > 0) then 
													{
													RHQ_Cargo set [(count RHQ_Cargo),_class];
													if ((((count _turrets) + (count ((getArray (_vehClass2 >> "Weapons")) - ["CMFlareLauncher"]))) < 1)) then
														{
														RHQ_NCCargo set [(count RHQ_NCCargo),_class];
														}
													};
												
												RHQ_Air set [(count RHQ_Air),_class];

												if (_fac in RYD_WS_SelectedFactions) then
													{
													switch (_side) do
														{
														case (0) : {RYD_WS_O_Air_G2 set [(count RYD_WS_O_Air_G2),_class]};
														case (1) : {RYD_WS_B_Air_G2 set [(count RYD_WS_B_Air_G2),_class]};
														case (2) : {RYD_WS_I_Air_G2 set [(count RYD_WS_I_Air_G2),_class]};
														}
													};
												
												if ((((count _turrets) + (count ((getArray (_vehClass2 >> "Weapons")) - ["CMFlareLauncher"]))) < 1)) then
													{
													RHQ_NCAir set [(count RHQ_NCAir),_class];
													}
												};
																								
											if (_isUAV) then
												{
												RHQ_Air set [(count RHQ_Air),_class];
												RHQ_RAir set [(count RHQ_RAir),_class]
												}
											}
										};
										
									if (not (_isCargo) and {not (_class in (RYD_WS_Cargo_class + RHQ_NCCargo))}) then
										{
										RHQ_Cargo pushBack _class;
										};
										
									if not (_class in (RYD_WS_NCCargo_class + RHQ_NCCargo)) then
										{	
										if not (_isMainT) then
											{
											if (_isCargo) then
												{
												RHQ_NCCargo pushBack _class;
												if (_sim in ["carx","helicopterx","helicopterrtd"]) then
													{
													if (_fac in RYD_WS_SelectedFactions) then
														{
														if (({_x} count [_isAmmoS,_isFuelS,_isRepS,_isMedS]) < 1) then
															{
															switch (_side) do
																{
																case (0) : {RYD_WS_O_NCCargo_G2 set [(count RYD_WS_O_NCCargo_G2),_class]};
																case (1) : {RYD_WS_B_NCCargo_G2 set [(count RYD_WS_B_NCCargo_G2),_class]};
																case (2) : {RYD_WS_I_NCCargo_G2 set [(count RYD_WS_I_NCCargo_G2),_class]};
																}
															}
														}
													}
												}
											}
										}	
									}
								else
									{
									_desc = toLower (getText (_vehClass2 >> "textSingular"));
									
									if (_desc in ["officer"]) then
										{
										if (_fac in RYD_WS_SelectedFactions) then
											{
											switch (_side) do
												{
												case (0) : {RYD_WS_O_Officers_G2 set [(count RYD_WS_O_Officers_G2),_class]};
												case (1) : {RYD_WS_B_Officers_G2 set [(count RYD_WS_B_Officers_G2),_class]};
												case (2) : {RYD_WS_I_Officers_G2 set [(count RYD_WS_I_Officers_G2),_class]};
												}
											}
										};									
									}
								}
							}
						}
					}
				}
			}
		}
	};
	
RYD_WS_isOnMap = 
	{
	private ["_pos","_onMap"];
	
	_pos = _this select 0;
	
	if (isNil "_pos") exitWith {false};
	if not (typeName _pos in [(typeName [])]) exitWith {false};
	
	_pos = +_pos;
	_pos reSize 2;

	if (({not (isNil {_x})} count _pos) < 2) exitWith {false};
	if (({(typeName _x) in [(typeName 0)]} count _pos) < 2) exitWith {false};
		
	_onMap = switch (true) do
		{
		case (({_x < 0} count _pos) > 0) : {false};
		case (not (isNil "RydBB_MC") and {not (_pos inArea RydBB_MC)}) : {false};
		case ((isNil "RydBB_MC") and {(({_x > RydBB_MapXMax} count _pos) > 0)}) : {false};
		default {true}
		};
		
	_onMap
	};

RYD_WS_MapAnalyze = 
	{
	private ["_cntr","_mapSize","_lng","_nmbr","_nbr","_secpos","_sPosX","_sPosY","_sUrban","_sForest","_sHills","_sFlat","_sSea","_samplePos","_topArr","_sRoads","_nbr","_sum","_mark","_sectors","_strArea",
	"_objRad","_loc10","_loc5","_loc2","_loc1","_locHill","_frstV","_k","_j","_fAr","_fPnt","_fVal","_fTkn","_fX","_fY","_sAr","_sPnt","_sVal","_sTkn","_sX","_sY"];
	
	_cntr = getArray (configFile >> "CfgWorlds" >> worldName >> "centerPosition");
	RYD_WS_CenterPosition = _cntr;

	if not (isNil "RydBB_MC") then
		{
		if ((typeName RydBB_MC) == "OBJECT") then {_cntr = getPosATL RydBB_MC} else {_cntr = RydBB_MC};
		RydBB_MapC = _cntr;
		}
	else
		{
		_mapSize = getNumber (configFile >> "CfgWorlds" >> worldName >> "mapSize");
		
		RydBB_MapXMax = _mapSize;
		RydBB_MapYMax = RydBB_MapXMax;
		RydBB_MapC = [_mapSize/2,_mapSize/2];

		_cntr = RydBB_MapC
		};

	//if ((_cntr select 0) < 1000) then {_cntr = getArray (configFile >> "CfgWorlds" >> worldName >> "centerPosition")};

	//_mark = "center" + str (random 1000);
	//_mark = [_mark,_cntr,"ColorBlue","ICON",[1.5,1.5],0,1,"DOT",(str _cntr)] call RYD_Marker;

	_lng = (_cntr select 0)*2;
	if not (isNil "RydBB_MC") then
		{
		if ((typeName RydBB_MC) == "OBJECT") then
			{
			_lng = ((triggerArea RydBB_MC) select 0)*2
			}
		else
			{
			_lng = RydBB_MapLng
			};

		RydBB_MapXMax = (RydBB_MapC select 0) + _lng/2;
		RydBB_MapYMax = (RydBB_MapC select 1) + _lng/2;
		RydBB_MapXMin = (RydBB_MapC select 0) - _lng/2;
		RydBB_MapYMin = (RydBB_MapC select 1) - _lng/2;
		};

	_nmbr = round (_lng/500);

	missionNameSpace setVariable ["BattleF",[_cntr,_lng,_nmbr]];

	RydBB_Sectors = ([_cntr,_lng,0,_nmbr] call RYD_Sectorize) select 0;
	
	/*_markers = [];

		{
		diag_log format ["Sector: %1",_x];
		_mark = "sector" + str (random 1000);
		_mark = [_mark,position _x,"ColorBlue","RECTANGLE",size _x,direction _x,1,"Border",""] call RYD_Marker;
		_markers set [(count _markers),_mark];
		_x setVariable ["Over_Mark",_mark];
		}
	foreach RydBB_Sectors;*/


	_nbr = 0;

	if (RydBB_Debug) then {diag_log "Big Boss studies the map."};

		{
		_x setVariable ["BBSec",true];		

		_secpos = position _x;
		_sPosX = _secpos select 0;
		_sPosY = _secpos select 1;

		_sUrban = 0;
		_sForest = 0;
		_sHills = 0;
		_sFlat = 0;
		_sSea = 0;
		_sGr = 0;
		_count = 10;

		for "_i" from 1 to _count do
			{
			_samplePos = [_sPosX + ((random 500) - 250),_sPosY + ((random 500) - 250)];

			_topArr = [_samplePos,1] call RYD_TerraCognita;

			_sUrban = _sUrban + (_topArr select 0);
			_sForest = _sForest + (_topArr select 1);
			_sHills = _sHills + (_topArr select 2);
			_sFlat = _sFlat + (_topArr select 3);
			_sSea = _sSea + (_topArr select 4);
			_sGr = _sGr + (_topArr select 5);
			};

		_sUrban = round (_sUrban*100/_count);
		_sForest =  round (_sForest*100/_count);
		_sHills =  round(_sHills*100/_count);
		_sFlat =  round (_sFlat*100/_count);
		_sSea = round (_sSea*100/_count);
		_sGr = round (_sGr*10/_count);

		_x setVariable ["Topo_Urban",_sUrban];
		_x setVariable ["Topo_Forest",_sForest];
		_x setVariable ["Topo_Hills",_sHills];
		_x setVariable ["Topo_Flat",_sFlat];
		_x setVariable ["Topo_Sea",_sSea];
		_x setVariable ["Topo_Grd",_sGr];
		
		_sum = _sUrban + _sForest + _sHills + _sFlat + _sSea;
		
		_sUrban = round (_sUrban*100/_sum);
		_sForest =  round (_sForest*100/_sum);
		_sHills =  round(_sHills*100/_sum);
		_sFlat =  round (_sFlat*100/_sum);
		_sSea = round (_sSea*100/_sum);
		_sGr = round (_sGr*100/_sum);
		
		_x setVariable ["Topo_UrbanP",_sUrban];
		_x setVariable ["Topo_ForestP",_sForest];
		_x setVariable ["Topo_HillsP",_sHills];
		_x setVariable ["Topo_FlatP",_sFlat];
		_x setVariable ["Topo_SeaP",_sSea];
		_x setVariable ["Topo_GrdP",_sGr];	

		_sRoads = count (_secpos nearRoads 250);

		_x setVariable ["Topo_roads",_sRoads];

		_mark = _x getVariable "Over_Mark";

		_nbr = _nbr + 1;
		_sum = count RydBB_Sectors;

		if not (isMultiplayer) then
			{
			progressLoadingScreen (_nbr/(2 * _sum))
			}
		}
	foreach RydBB_Sectors;

	RydBB_mapReady = true;

	_sectors = RydBB_Sectors;

	_strArea = [];

	if (RydBB_Debug) then
		{
		//RydBBa_SAL globalChat format ["Big Boss %1 is looking for strategic objectives.",_BBSide];
		diag_log "Big Boss is looking for strategic objectives."
		};

	_objRad = 25000;

	_cntr = (missionNameSpace getVariable "BattleF") select 0;
	_lng = (missionNameSpace getVariable "BattleF") select 1;

	if not (isNil "RydBB_MC") then
		{
		_objRad = _lng/2
		};

	_loc10 = nearestLocations [_cntr, ["NameCityCapital"], _objRad]; 
	_loc5 = nearestLocations [_cntr, ["NameCity","Airport"], _objRad]; 
	_loc2 = nearestLocations [_cntr, ["NameVillage"], _objRad]; 
	
		{
		if ((tolower (text _x)) in ["sagonisi"]) exitWith
			{
			_loc2 set [_foreachIndex, "deleteThis"]
			}
		}
	foreach _loc2;
	
	_loc2 = _loc2 - ["deleteThis"];
	
	_loc1 = nearestLocations [_cntr, ["BorderCrossing"], _objRad]; 
	_locHill = nearestLocations [_cntr, ["Hill","ViewPoint"], _objRad]; 

		{
		_strArea set [(count _strArea),[(position _x),10,false]]
		}
	foreach _loc10;

		{
		_strArea set [(count _strArea),[(position _x),5,false]]
		}
	foreach _loc5;

		{
		_strArea set [(count _strArea),[(position _x),2,false]]
		}
	foreach _loc2;

		{
		_strArea set [(count _strArea),[(position _x),1,false]]
		}
	foreach _loc1;


		{
		_topArr = [(position _x),3] call RYD_TerraCognita;
		_frstV = _topArr select 1;
		if (_frstV > 0.25) then 
			{
			_strArea set [(count _strArea),[(position _x),1,false]]
			}
		else
			{
			_strArea set [(count _strArea),[(position _x),2,false]]
			}
		}
	foreach _locHill;
	
	if (not (isNil "RydBB_MC") and {((typeName RydBB_MC) isEqualTo (typeName objNull))}) then
		{
			{
			if not ((_x select 0) inArea RydBB_MC) then
				{
				_strArea set [_foreachIndex,0]
				}
			}
		foreach _strArea
		};
		
	_strArea = _strArea - [0];

	//_strArea = [];
	
	if ((count _strArea) < 20) then
		{
		_sectorsL = [];
		
			{
			_sea = _x getVariable ["Topo_Sea",0];
			if (_sea < 1) then
				{
				if (((isNil "RydBB_MC") or {not ((typeName RydBB_MC) isEqualTo (typeName objNull))}) or {((position _x) inArea RydBB_MC)}) then
					{
					_sectorsL pushBack _x;
					_x setVariable ["RYD_myLocIx",(_foreachIndex + 1)];
					}
				}
			}
		foreach _sectors;
		_sectors2 = [_sectorsL] call RYD_RandomOrdB;
		_tresh = 100;
		_wantedAm = ((round ((count _sectors)/75)) max 5) min 100;
		while {((count _strArea) < _wantedAm)} do
			{
				{
				_pos = position _x;
				_nearS = [_pos,_sectorsL,0,750,8] call RYD_WS_FindSectorInRange;
				_urban = (_x getVariable ["Topo_Urban",0]) * 1.75;
				if ((_urban > _tresh) and {(({not ((_x getVariable ["Topo_Urban",0]) < _urban)} count _nearS) < 1)}) then
					{
					_strArea pushBack [_pos,1,false];
					_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
					_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
					_sectors2 set [_foreachIndex,0];
					//_mark = "sectorU" + (str _pos);
					//_mark = [_mark,_pos,"ColorGrey","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
					//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["U: %1",_urban])] call RYD_Marker;
					}
				else
					{
					_forest = (_x getVariable ["Topo_Forest",0])/1.5;
					if ((_forest > _tresh) and {(({not ((_x getVariable ["Topo_Forest",0]) < _forest)} count _nearS) < 1)}) then 
						{
						_strArea pushBack [_pos,1,false];
						_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
						_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
						_sectors2 set [_foreachIndex,0];
						//_mark = "sectorF" + (str _pos);
						//_mark = [_mark,_pos,"ColorGreen","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
						//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["F: %1",_forest])] call RYD_Marker;
						}
					else
						{
						_hills = (_x getVariable ["Topo_Hills",0])/1.1;
						if ((_hills > _tresh) and {(({not ((_x getVariable ["Topo_Hills",0]) < _hills)} count _nearS) < 1)}) then 
							{
							_strArea pushBack [_pos,1,false];
							_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
							_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
							_sectors2 set [_foreachIndex,0];
							//_mark = "sectorH" + (str _pos);
							//_mark = [_mark,_pos,"ColorKhaki","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
							//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["H: %1",_hills])] call RYD_Marker;
							}
						else
							{
							_grd = (_x getVariable ["Topo_Grd",0])/5;
							if ((_grd > _tresh) and {(({not ((_x getVariable ["Topo_Grd",0]) < _grd)} count _nearS) < 1)}) then 
								{
								_strArea pushBack [_pos,1,false];
								_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
								_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
								_sectors2 set [_foreachIndex,0];
								//_mark = "sectorG" + (str _pos);
								//_mark = [_mark,_pos,"ColorRed","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
								//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["G: %1",_grd])] call RYD_Marker;
								}
							}
						}
					}
				}
			foreach _sectors2;
			
			_tresh = _tresh - 20;
			if (_tresh < 0) exitWith {};
			_sectors2 = _sectors2 - [0];
			};
		};
	
	if ((count _strArea) < 1) then
		{
		_sectorsL = [];
		
			{
			_sea = _x getVariable ["Topo_Sea",0];
			if (_sea < 100) then
				{
				if (((isNil "RydBB_MC") or {not ((typeName RydBB_MC) isEqualTo (typeName objNull))}) or {((position _x) inArea RydBB_MC)}) then
					{
					_sectorsL pushBack _x;
					_x setVariable ["RYD_myLocIx",(_foreachIndex + 1)];
					}
				}
			}
		foreach _sectors;
		_sectors2 = [_sectorsL] call RYD_RandomOrdB;
		
			{
			_pos = position _x;
			_nearS = [_pos,_sectorsL,0,750,8] call RYD_WS_FindSectorInRange;
			_urban = (_x getVariable ["Topo_Urban",0]) * 1.75;
			if (({not ((_x getVariable ["Topo_Urban",0]) < _urban)} count _nearS) < 1) then
				{
				_strArea pushBack [_pos,1,false];
				_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
				_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
				//_mark = "sectorU" + (str _pos);
				//_mark = [_mark,_pos,"ColorGrey","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
				//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["U: %1",_urban])] call RYD_Marker;
				}
			else
				{
				_forest = (_x getVariable ["Topo_Forest",0])/1.5;
				if (({not ((_x getVariable ["Topo_Forest",0]) < _forest)} count _nearS) < 1) then 
					{
					_strArea pushBack [_pos,1,false];
					_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
					_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
					//_mark = "sectorF" + (str _pos);
					//_mark = [_mark,_pos,"ColorGreen","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
					//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["F: %1",_forest])] call RYD_Marker;
					}
				else
					{
					_hills = (_x getVariable ["Topo_Hills",0])/1.1;
					if (({not ((_x getVariable ["Topo_Hills",0]) < _hills)} count _nearS) < 1) then 
						{
						_strArea pushBack [_pos,1,false];
						_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
						_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
						//_mark = "sectorH" + (str _pos);
						//_mark = [_mark,_pos,"ColorKhaki","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
						//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["H: %1",_hills])] call RYD_Marker;
						}
					else
						{
						_grd = (_x getVariable ["Topo_Grd",0])/5;
						if (({not ((_x getVariable ["Topo_Grd",0]) < _grd)} count _nearS) < 1) then 
							{
							_strArea pushBack [_pos,1,false];
							_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
							_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
							//_mark = "sectorG" + (str _pos);
							//_mark = [_mark,_pos,"ColorRed","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
							//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["G: %1",_grd])] call RYD_Marker;
							}
						else
							{
							if (({((_x getVariable ["Topo_Sea",0]) <= _sea)} count _nearS) < 1) then 
								{
								_strArea pushBack [_pos,1,false];
								_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
								_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
								//_mark = "sectorL" + (str _pos);
								//_mark = [_mark,_pos,"ColorWhite","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
								//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["L: %1",_sea])] call RYD_Marker;
								}
							}
						}
					}
				}
			}
		foreach _sectors2;
		};
	
	_strArea0 = +_strArea;

		{
		_fAr = _x;
		_k = _foreachIndex;
		_fPnt = _fAr select 0;
		_fVal = _fAr select 1;
		_fTkn = _fAr select 2;

		_fX = _fPnt select 0;
		_fY = _fPnt select 1;

			{
			_sAr = _x;
			_j = _foreachIndex;
			_sPnt = _sAr select 0;
			_sVal = _sAr select 1;
			_sTkn = _sAr select 2;

			_sX = _sPnt select 0;
			_sY = _sPnt select 1;

			if ((_fPnt distance _sPnt) < 400) then
				{
				if not ((_fPnt select 0) == (_sPnt select 0)) then 
					{
					if (_fVal > _sVal) then
						{
						_strArea set [_k,[[(_fX + _sX)/2,(_fY + _sY)/2,0],_fVal + _sVal,_fTkn]];
						_strArea set [_j,"deleteThis"]
						}
					else
						{
						_strArea set [_j,[[(_fX + _sX)/2,(_fY + _sY)/2,0],_fVal + _sVal,_sTkn]];
						_strArea set [_k,"deleteThis"]
						}
					}
				}
			}
		foreach _strArea0
		}
	foreach _strArea0;

	_strArea = _strArea - ["deleteThis"];
	
	_strArea0 = nil;

	missionNameSpace setVariable ["A_SAreas",_strArea];
	missionNameSpace setVariable ["B_SAreas",_strArea];
	
	true
	};
	
RYD_WS_Battlefield = 
	{
	_mode = _this select 0;
	_taken = _this select 1;

	_strAr = if ((count RYD_WS_BattlePosition) < 2) then
		{
		+(missionNameSpace getVariable ["A_SAreas",[]])
		}
	else
		{
		[[RYD_WS_BattlePosition,1,false]]
		};

	_posArray = [];
	
	switch (true) do
		{
		case (_mode in [0,1]) :
			{
			_defPos = [];
			_attPos = [];
			
			_ct = 0;
			_nearSea = 0;
			
			_excluded = +(_taken select _mode);
			_taken set [_mode,-1];
			_taken = _taken - [-1];
			_taken = +(_taken select 0);
			
			_strAr0 = [];
			
				{
				_pos = _x select 0;
				
				if (({((_pos distance _x) < 350)} count _taken) > 0) then
					{
					_strAr0 set [(count _strAr0),_x]
					}
				}
			foreach _strAr;
			
			if (((count _strAr0) > 0) and ((random 100) < 30)) then
				{
				_strAr = _strAr0
				}
			else
				{				
					{
					_pos = _x select 0;
					
					if (({((_pos distance _x) < 400)} count _excluded) > 0) then
						{
						_strAr set [_foreachIndex,0]
						}
					}
				foreach _strAr;
				
				_strAr = _strAr - [0]
				};
			
			if ((count _strAr) < 1) then
				{
				_strAr = if ((count RYD_WS_BattlePosition) < 2) then
					{
					+(missionNameSpace getVariable ["A_SAreas",[]])
					}
				else
					{
					[[RYD_WS_BattlePosition,1,false]]
					};
				};
			
			while {(((count _attPos) < 2) or not ([_attPos] call RYD_WS_isOnMap) or {_nearSea > 10})} do
				{
				_defPos = (_strAr select (floor (random (count _strAr)))) select 0;
				
				_attPos = [_defPos,_strAr,1500,3000] call RYD_WS_FindPosInRange;
				_nearSeaD = [_defPos,600] call RYD_WS_NearSea;
				_nearSeaA = [_attPos,600] call RYD_WS_NearSea;
				_nearSea = _nearSeaD max _nearSeaA;
				_ct = _ct + 1;
				if (_ct > 20) exitWith {_attPos = [_defPos,10,100] call RYD_RandomAroundMM}
				};
			
			_posArray = switch (_mode) do
				{	
				case (0) : {[_defPos,_attPos,_defPos]};
				case (1) : {[_attPos,_defPos,_defPos]}
				}
			};
			
		case (_mode in [2]) :
			{
			_center = (_strAr select (floor (random (count _strAr)))) select 0;
				
			_posA = [_center,800,1600,50] call RYD_WS_FindLandPos;
			_nearSea = [_posA,600] call RYD_WS_NearSea;
			
			_ct = 0;
			
			while {((surfaceIsWater _posA) or not ([_posA] call RYD_WS_isOnMap) or {_nearSea > 10})} do
				{
				_center = (_strAr select (floor (random (count _strAr)))) select 0;
				
				_posA = [_center,1200,2400,50] call RYD_WS_FindLandPos;
				_nearSea = [_posA,600] call RYD_WS_NearSea;
				_ct = _ct + 1;
				if (_ct > 10) exitWith {_posA = [_center,100,300] call RYD_RandomAroundMM}
				};
				
			_battlePoint = +_center;
			
			_angleA = [_center,_posA,0] call RYD_AngTowards;
			
			_center = [_battlePoint,_angleA + 210 - (random 60),1800] call RYD_PosTowards2D;
			
			_posB = [_center,0,400,50] call RYD_WS_FindLandPos;
			_nearSea = [_posB,600] call RYD_WS_NearSea;
			
			_ct = 0;
			
			while {((surfaceIsWater _posB) or (_nearSea > 10))} do
				{
				_center = [_battlePoint,_angleA + 210 - (random 60),1800 + (((2 * _ct) - 10) * 50)] call RYD_PosTowards2D;
				
				_posB = [_center,0,400,50] call RYD_WS_FindLandPos;
				_nearSea = [_posB,600] call RYD_WS_NearSea;
				_ct = _ct + 1;
				if (_ct > 10) exitWith {_posB = [_battlePoint,100,300] call RYD_RandomAroundMM}
				};
			
			_posArray = [_posA,_posB,_battlePoint]
			};
		};
		
		{
		_x set [2,0]
		}
	foreach _posArray;
	
	_posArray
	};
	
RYD_WS_Forces = 
	{
	_mode = _this select 0;
	_scale = _this select 1;
	_sides = _this select 2;
	_topoCoeff = sqrt (_this select 3);
	
	_infPoolA = [];
	_motPoolA = [];
	_mechPoolA = [];
	_armPoolA = [];
	
	_infPoolB = [];
	_motPoolB = [];
	_mechPoolB = [];
	_armPoolB = [];
	
	_infPool = [];
	_motPool = [];
	_mechPool = [];
	_armPool = [];	
		
	switch (_sides select 0) do
		{
		case (west) : 
			{
			_infPoolA = RYD_WS_B_Infantry_G;
			_motPoolA = RYD_WS_B_Motorized_G;
			_mechPoolA = RYD_WS_B_Mechanized_G;
			_armPoolA = RYD_WS_B_Armored_G
			};
			
		case (east) : 
			{
			_infPoolA = RYD_WS_O_Infantry_G;
			_motPoolA = RYD_WS_O_Motorized_G;
			_mechPoolA = RYD_WS_O_Mechanized_G;
			_armPoolA = RYD_WS_O_Armored_G
			};
			
		case (resistance) : 
			{
			_infPoolA = RYD_WS_I_Infantry_G;
			_motPoolA = RYD_WS_I_Motorized_G;
			_mechPoolA = RYD_WS_I_Mechanized_G;
			_armPoolA = RYD_WS_I_Armored_G
			};
		};
		
	switch (_sides select 1) do
		{
		case (west) : 
			{
			_infPoolB = RYD_WS_B_Infantry_G;
			_motPoolB = RYD_WS_B_Motorized_G;
			_mechPoolB = RYD_WS_B_Mechanized_G;
			_armPoolB = RYD_WS_B_Armored_G
			};
			
		case (east) : 
			{
			_infPoolB = RYD_WS_O_Infantry_G;
			_motPoolB = RYD_WS_O_Motorized_G;
			_mechPoolB = RYD_WS_O_Mechanized_G;
			_armPoolB = RYD_WS_O_Armored_G
			};
			
		case (resistance) : 
			{
			_infPoolB = RYD_WS_I_Infantry_G;
			_motPoolB = RYD_WS_I_Motorized_G;
			_mechPoolB = RYD_WS_I_Mechanized_G;
			_armPoolB = RYD_WS_I_Armored_G
			};
		};
		
	RYD_WS_HQGuardsA = [_infPoolA,_motPoolA,_mechPoolA];
	RYD_WS_HQGuardsB = [_infPoolB,_motPoolB,_mechPoolB];
	
	_forcesA_inf = [];
	_forcesA_mot = [];
	_forcesA_mech = [];
	_forcesA_arm = [];
	
	_forcesB_inf = [];
	_forcesB_mot = [];
	_forcesB_mech = [];
	_forcesB_arm = [];
	
	_forces = [[_forcesA_inf,_forcesA_mot,_forcesA_mech,_forcesA_arm],[_forcesB_inf,_forcesB_mot,_forcesB_mech,_forcesB_arm]];
		
	_arr = 0;
	_gps = [];
	
	_amountA = (11 + (floor (random 3))) * _scale;
	_amountB = (11 + (floor (random 3))) * _scale;
	
	_sumAm = _amountA + _amountB;
	
	_amountB = round ((_sumAm/(1 + RYD_WS_Ratio)) * (sqrt RYD_WS_AdvantageB));
	_amountA = round ((_amountB * RYD_WS_Ratio) * (sqrt RYD_WS_AdvantageA));
	
	//diag_log format ["A: %1 B: %2",_amountA,_amountB];
	
		{
		_artyC = 0;
		
		_ratio = switch (_foreachIndex) do
			{
			case (0) : {RYD_WS_Ratio};
			case (1) : {1/RYD_WS_Ratio};
			};
			
		_HSratio = switch (_foreachIndex) do
			{
			case (0) : {RYD_WS_HSRatio_A};
			case (1) : {RYD_WS_HSRatio_B};
			};
		
		_inf = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_inf};
			case (1) : {_forcesB_inf};
			};
			
		_mot = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_mot};
			case (1) : {_forcesB_mot};
			};
			
		_mech = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_mech};
			case (1) : {_forcesB_mech};
			};
			
		_arm = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_arm};
			case (1) : {_forcesB_arm};
			};
			
		switch (_foreachIndex) do
			{
			case (0) :
				{
				_infPool = _infPoolA;
				_motPool = _motPoolA;
				_mechPool = _mechPoolA;
				_armPool = _armPoolA
				};
				
			case (1) :
				{
				_infPool = _infPoolB;
				_motPool = _motPoolB;
				_mechPool = _mechPoolB;
				_armPool = _armPoolB				
				};
			};

		_amount = switch (_foreachIndex) do
			{
			case (0) : {_amountA};
			case (1) : {_amountB};
			};
			
		_mpl = 1;
		
		if (_mode == _foreachIndex) then
			{
			if ((random 100) < 90) then
				{
				_mpl = 0.75
				};
				
			if ((random 100) < 85) then
				{
				if (((_foreachIndex == 0) and ((_amount * 1.5) > _amountB)) or ((_foreachIndex == 1) and ((_amount * 1.5) > _amountA))) then
					{
					_amount = ceil ((_amount/(1 + (random 0.75) + (random 0.75))));
					}
				}
			};
			
		//diag_log format ["am: %1 sc: %2",_amount,_scale];
		
		_notEmpty = [];
		_fcs = [_inf,_mot,_mech,_arm];
		
			{
			if ((count _x) > 0) then
				{
				_notEmpty set [(count _notEmpty),[_x,_fcs select _foreachIndex]]
				}
			}
		foreach [_infPool,_motPool,_mechPool,_armPool];
		
		if ((count _notEmpty) > 0) then
			{	
			for "_ixA" from 1 to _amount do
				{
				_rnd = (random 100) * _mpl;
				
				_infC = (50 * (((_topoCoeff * _HSratio) min 1.9) max 0.1));
				_motC = (80 * ((((_topoCoeff max 0.4) * _HSratio) min 1.2)) max 0.1);
				_mechC = (80 * (((_topoCoeff * _HSratio) min 1.2)) max 0.3);
				
				//diag_log format ["tcoeff: %1 ratio: %2 infc: %3 motc: %4 mechc: %5 rnd: %6",_topoCoeff,_HSratio,_infC,_motC,_mechC,_rnd];
				
				switch (true) do
					{
					case ((_rnd < _infC) or {((_HSratio == 0) and {((random 100) < 80)})}) :
						{
						_gps = _infPool;
						_arr = _inf;
						//diag_log format ["inf: %1",count _gps];
						if ((count _gps) < 1) then
							{
							_sec = _notEmpty select (floor (random (count _notEmpty)));
							_gps = _sec select 0;
							_arr = _sec select 1
							}
						};
						
					case ((_rnd < _motC) or {(_HSratio == 0)}) :
						{
						_gps = _motPool;
						_arr = _mot;
						//diag_log format ["mot: %1",count _gps];
						if ((count _gps) < 1) then
							{
							_sec = _notEmpty select (floor (random (count _notEmpty)));
							_gps = _sec select 0;
							_arr = _sec select 1
							}
						};
						
					default
						{
						_rnd = (random 100) * _mpl;
						
						if (_rnd < _mechC) then
							{
							_gps = _mechPool;
							_arr = _mech;
							//diag_log format ["mech: %1",count _gps];
							if ((count _gps) < 1) then
								{
								_sec = _notEmpty select (floor (random (count _notEmpty)));
								_gps = _sec select 0;
								_arr = _sec select 1
								}							
							}
						else
							{
							_gps = +_armPool;
							_arr = _arm;
							
							if (0.5 < (random (1 + (_artyC^2)))) then
								{
									{
									if (_x select 2) then
										{
										_gps set [_foreachIndex,0]
										}
									}
								foreach _gps;
								
								_gps = _gps - [0]
								};
							//diag_log format ["tank: %1",count _gps];
							if ((count _gps) < 1) then
								{
								_sec = _notEmpty select (floor (random (count _notEmpty)));
								_gps = _sec select 0;
								_arr = _sec select 1
								}
							}
						}
					};
					
				_gp = _gps select (floor (random (count _gps)));

				if (_gp select 2) then
					{
					_artyC = _artyC + 1
					};
				
				_arr set [(count _arr),[_gp select 0,_gp select 1,_gp select 3,_gp select 2]]
				};
			}
		}
	foreach [0,1];

	_forces
	};
	
RYD_WS_FindLandPos = 
	{
	private ["_center","_minR","_maxR","_maxT","_final","_ct","_nearSea","_noWater"];
	
	_center = _this select 0;
	_minR = _this select 1;
	_maxR = _this select 2;
	_maxT = _this select 3;
	_noWater = 600;
	if ((count _this) > 4) then {_noWater = _this select 4};
	
	_final = [_center,_minR,_maxR] call RYD_RandomAroundMM;
	_nearSea = [_final,_noWater] call RYD_WS_NearSea;
	
	_ct = 0;
	
	while {((surfaceIsWater _final) or not ([_final] call RYD_WS_isOnMap) or {_nearSea > 10})} do
		{
		_final = [_center,_minR,_maxR] call RYD_RandomAroundMM;
		
		_maxR = _maxR + (_maxR/(2 * _maxT));
		
		_nearSea = [_final,_noWater] call RYD_WS_NearSea;
		_ct = _ct + 1;
		if (_ct > _maxT) exitWith {}
		};
		
	_final
	};
	
RYD_WS_FindPosInRange = 
	{
	private ["_center","_areas","_minR","_maxR","_final","_inRange","_pos","_dst","_nearSea"];
	
	_center = _this select 0;
	_areas = _this select 1;
	_minR = _this select 2;
	_maxR = _this select 3;
	
	_final = [0,0,0];
	_inRange = [];
	
	if ((random 100) > 30) then
		{
			{
			_pos = _x select 0;
			_dst = _center distance _pos;
			
			if (_dst < _maxR) then
				{
				if (_dst > _minR) then
					{
					_nearSea = [_pos,600] call RYD_WS_NearSea;
					
					if (_nearSea < 10) then
						{
						_inRange set [(count _inRange),_pos]
						}
					}
				}
			}
		foreach _areas
		};
	
	if ((count _inRange) > 0) then
		{
		_final = _inRange select (floor (random (count _inRange)));
		}
	else
		{
		_final = [_center,_minR,_maxR,100] call RYD_WS_FindLandPos
		};
	
	_final
	};
	
RYD_WS_FindSectorInRange = 
	{
	private ["_center","_areas","_minR","_maxR","_tresh","_inRange","_pos","_dst"];
	
	_center = _this select 0;
	_areas = _this select 1;
	_minR = _this select 2;
	_maxR = _this select 3;
	_tresh = if ((count _this) > 4) then
		{
		(_this select 4)
		}
	else
		{
		-1
		};

	_inRange = [];
	
		{
		_pos = position _x;
		_dst = _center distance _pos;
		
		if (_dst < _maxR) then
			{
			if (_dst > _minR) then
				{
				_inRange pushBack _x
				}
			};
			
		if ((count _inRange) == _tresh) exitWith {};
		}
	foreach _areas;
	
	_inRange
	};
	
RYD_WS_Topo = 
	{
	private ["_center","_range","_nearS","_sumUrban","_sumForest","_sumHills","_sumFlat","_sumGrd","_sUrban","_sForest","_sHill","_sFlat","_sGrd","_cntNS","_urbanF","_forestF","_hillsF","_flatF","_grdF"];

	_center = _this select 0;
	_range = _this select 1;

	_nearS = [_center,RydBB_Sectors,0,_range] call RYD_WS_FindSectorInRange;

	RYD_WS_NearSectors = _nearS;

	_sumUrban = 0;
	_sumForest = 0;
	_sumHills = 0;
	_sumFlat = 0;
	_sumGrd = 0;

		{		
		_sUrban = _x getVariable "Topo_UrbanP";
		_sForest = _x getVariable "Topo_ForestP";
		_sHill = _x getVariable "Topo_HillsP";
		_sFlat = _x getVariable "Topo_FlatP";
		_sGrd = _x getVariable "Topo_GrdP";
		
		_sumUrban = _sumUrban + _sUrban;
		_sumForest = _sumForest + _sForest;
		_sumHills = _sumHills + _sHill;
		_sumFlat = _sumFlat + _sFlat;
		_sumGrd = _sumGrd + _sGrd;
		}
	foreach _nearS;

	_cntNS = (count _nearS) max 1;

	_urbanF = _sumUrban/_cntNS;
	_forestF = _sumForest/_cntNS;
	_hillsF = _sumHills/_cntNS;
	_flatF = _sumFlat/_cntNS;
	_grdF = _sumGrd/_cntNS;

	[_urbanF,_forestF,_hillsF,_flatF,_grdF]
	};
	
RYD_WS_NearSea = 
	{
	private ["_center","_range","_nearS","_sumSea","_sSea","_sumSea","_cntNS","_seaF"];
	
	_center = _this select 0;
	_range = _this select 1;

	_nearS = [_center,RydBB_Sectors,0,_range] call RYD_WS_FindSectorInRange;

	_sumSea = 0;

		{		
		_sSea = _x getVariable "Topo_SeaP";

		_sumSea = _sumSea + _sSea;
		}
	foreach _nearS;

	_cntNS = (count _nearS) max 1;

	_seaF = _sumSea/_cntNS;
	
	_seaF
	};
	
RYD_WS_SpawnGroupSafe = 
	{//based on BIS_fnc_spawnGroup by BI Studio (Joris-Jan van 't Land (modified by Thomas Ryan))
	private ["_pos","_side","_count","_chars","_ranks","_positions","_item","_types","_safePos","_rP","_rnd","_ct","_typesC","_del","_types","_grp","_ourVehs","_type","_relPos","_itemPos","_unit",
	"_newGrp","_am","_maxRank","_rank","_out","_vh","_eP","_unit","_eD","_eG","_eC","_crw","_imp","_ic","_checked","_azimuth","_itemPos0","_fe","_nR","_cl","_pItems","_foundPos"];
		
	_pos = _this select 0;
	_side = _this select 1;
	
	_count = {(side _x) == _side} count allGroups;
	if (_count > 143) exitWith {grpNull};

	_chars = _this select 2;
	
	_ranks = [];
	//_positions = [[0,0,0]];
	_types = [];
	
	for "_ia" from 0 to ((count _chars) - 1) do 
		{
		_item = _chars select _ia;
		
		if (isClass _item) then 
			{
			_types set [(count _types),getText(_item >> "vehicle")];
			_ranks set [(count _ranks),getText(_item >> "rank")];
			
			/*if (_ia > 0) then
				{
				_safePos = [_pos,0,100,12,0,4,0] call BIS_fnc_findSafePos;
				_rP = [(_safePos select 0) - (_pos select 0),(_safePos select 1) - (_pos select 1),0.5];
				_positions set [(count _positions),_rP]
				}*/
			};
		};
	
	_grp = createGroup _side;
	_ourVehs = [];
	_azimuth = _this select 3;
	
	for "_ib" from 0 to ((count _types) - 1) do
		{
		_type = _types select _ib;
		_itemPos0 = +_pos;
		_itemPos = +_itemPos0;
		_foundPos = false;
		
		if (getNumber(configFile >> "CfgVehicles" >> _type >> "isMan") == 1) then 
			{
			_itemPos0 = [_pos,0,160,10,0,4,0,[],[_pos,_pos]] call BIS_fnc_findSafePos;
			_fe = not ((isOnRoad _itemPos0) or not ([_itemPos0] call RYD_WS_isOnMap));
			_nR = _itemPos0 nearRoads 50;
			if ((count _nR) > 0) then {_fe = false};

			if (_fe) then
				{
				_cl = [_itemPos0,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
				if (((_cl distance _itemPos0) < 10) or ((_pos distance _itemPos0) > 5000)) then {_fe = false} else {_foundPos = true;_itemPos = _itemPos0}
				};
			
			_ct = 0;
			
			while {(not _fe)} do
				{
				_ct = _ct + 1;
				if (_ct > 200) exitWith {};
				_itemPos = [_itemPos0,10,100 + (_ct * 5)] call RYD_RandomAroundMM;
				_itemPos = [_itemPos,0,160,10,0,4,0,[],[_itemPos,_itemPos]] call BIS_fnc_findSafePos;
				_fe = not ((isOnRoad _itemPos) or not ([_itemPos] call RYD_WS_isOnMap));
				_nR = _itemPos nearRoads 50;
				if ((count _nR) > 0) then {_fe = false};

				if (_fe) then
					{
					_cl = [_itemPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
					if (((_cl distance _itemPos) < 10) or ((_pos distance _itemPos) > 5000)) then {_fe = false} else {_foundPos = true}
					};
				};
			}
		else
			{
			_itemPos0 = [_pos,0,200,20,0,6,0,[],[_pos,_pos]] call BIS_fnc_findSafePos;
			_fe = not ((isOnRoad _itemPos0) or not ([_itemPos0] call RYD_WS_isOnMap));
			_nR = _itemPos0 nearRoads 50;
			if ((count _nR) < 1) then {_fe = false};

			if (_fe) then
				{
				_cl = [_itemPos0,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
				if (((_cl distance _itemPos0) < 12) or ((_pos distance _itemPos0) > 5000)) then {_fe = false} else {_foundPos = true;_itemPos = _itemPos0}
				};
			
			_ct = 0;
			
			while {(not _fe)} do
				{
				_ct = _ct + 1;
				if (_ct > 500) exitWith {};
				_itemPos = [_itemPos0,10,100 + (_ct * 5)] call RYD_RandomAroundMM;
				_itemPos = [_itemPos,0,200,20 - (_ct/10),0,6,0,[],[_itemPos,_itemPos]] call BIS_fnc_findSafePos;
				_fe = not ((isOnRoad _itemPos) or not ([_itemPos] call RYD_WS_isOnMap));
				_nR = _itemPos nearRoads (50 - (_ct/10));
				if ((count _nR) < 1) then {_fe = false};

				if (_fe) then
					{
					_cl = [_itemPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
					if (((_cl distance _itemPos) < 12) or ((_pos distance _itemPos) > 5000)) then {_fe = false} else {_foundPos = true}
					};
				};
				
			//diag_log format ["ct: %1",_ct];
			};

		 if not (_foundPos) exitWith {grpNull};
				
		/*if ((count _positions) > 0) then 
			{
			_relPos = _positions select _ib;
			_itemPos = [(_pos select 0) + (_relPos select 0), (_pos select 1) + (_relPos select 1)];
			} 
		else 
			{
			_itemPos = _pos;
			};*/
			
		RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_itemPos];

		if (getNumber(configFile >> "CfgVehicles" >> _type >> "isMan") == 1) then 
			{	
			_unit = _grp createUnit [_type, _itemPos, [], 0, "NONE"];
			_unit setDir _azimuth;
			} 
		else 
			{
			_unit = ([_itemPos, _azimuth, _type, _grp] call BIS_fnc_spawnVehicle) select 0;
			
			_isTurret = isClass (configfile >> "CfgVehicles" >> _type >> "Turrets" >> "MainTurret");
			
			if (_isTurret) then
				{
				_unit allowCrewInImmobile true
				};
			
			_ourVehs set [(count _ourVehs),_unit];
			};

		if ((count _ranks) > 0) then 
			{
			[_unit,_ranks select _ib] call bis_fnc_setRank;
			};
		};
		
	_grp setFormDir _azimuth;
		
	_newGrp = createGroup _side;
	
	_newGrp setFormDir _azimuth;
	_ct = 0;
	_am = {alive _x} count (units _grp);
	while {(({alive _x} count (units _grp)) > 0)} do 
		{
		_maxRank = -1;
		_unit = objnull;
		
			{
			_rank = rankid _x;
			if (_rank > _maxRank) then 
				{
				_maxRank = _rank;
				_unit = _x
				};
			} 
		foreach units _grp;
		
		[_unit] joinsilent _newGrp;
		
		_ct = _ct + 1;
		if (_ct > (_am + 1)) exitWith {}
		};
		
	_newGrp selectleader (units _newGrp select 0);
	deletegroup _grp;
	
	if ((count (units _newGrp)) < 1) exitWith {grpNull};
	
	if ((random 100) < 30) then
		{
		_pItems = assignedItems (leader _newGrp);
			
		if not (({(toLower _x) in ["nvgoggles","nvgoggles_indep","nvgoggles_opfor"]} count _pItems) > 0) then
			{
			(leader _newGrp) linkItem "NVGoggles_INDEP"
			};
		};
	
		{
		if ((random 100) < 100) then
			{
			_pItems = assignedItems _x;
			
			if not (({(toLower _x) in ["nvgoggles","nvgoggles_indep","nvgoggles_opfor"]} count _pItems) > 0) then
				{
				_pItems = primaryWeaponItems _x;
				if not (({(toLower _x) in ["acc_flashlight","acc_pointer_ir"]} count _pItems) > 0) then
					{
					_x addPrimaryWeaponItem "acc_flashlight"
					}
				}
			}
		}
	foreach (units _newGrp);
	
	_newGrp setVariable ["RYD_WS_OurVehs",_ourVehs];
		
	if ((count _ourVehs) > 0) then
		{
		_out = [];

			{
			if (_x == (vehicle _x)) then
				{
				_out set [(count _out),_x]
				}
			}
		foreach (units _newGrp);
		
		_imp = [+_out] call RYD_WS_SelectImportant;
				
		_unit = objNull;
		_eD = 0;
		_eG = 0;
		_eC = 0;
		
		if ((count _out) > 0) then
			{			
				{
				_vh = _x;
				
				_eD = _vh emptyPositions "Driver";
				_eG = _vh emptyPositions "Gunner";
				_eC = _vh emptyPositions "Commander";
				
				_vh setVariable ["RYD_WS_InitCrew",[_eD,_eG,_eC]];
				
				if (_eD > 0) then
					{
					if (_imp > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select 0;
						_out = _out - [_unit];						
						};
						
					_unit moveInDriver _vh				
					};
					
				if not ((count _out) > 0) exitWith {};
				
				if (_eG > 0) then
					{
					if ((count _imp) > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select 0;
						_out = _out - [_unit];						
						};
						
					_unit moveInGunner _vh				
					};
				
				if not ((count _out) > 0) exitWith {};
				
				if (_eC > 0) then
					{
					if ((count _imp) > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select 0;
						_out = _out - [_unit];						
						};
						
					_unit moveInCommander _vh				
					};
				
				if not ((count _out) > 0) exitWith {};
				
				_eP = _vh emptyPositions "Cargo";
				_ct = _eP;

				while {(_eP > 0)} do
					{
					if ((count _imp) > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select (floor (random (count _out)));
						_out = _out - [_unit];						
						};
					
					_unit moveInCargo _vh;
					
					if not ((count _out) > 0) exitWith {};
					
					_eP = _vh emptyPositions "Cargo";
					_ct = _ct - 1;
					if (_ct < -2) exitWith {}		
					};
					
				if not ((count _out) > 0) exitWith {};
				}
			foreach _ourVehs;
				
			if ((count _imp) > 0) then
				{
					{
					_vh = _x;
					
					_iC = _vh getVariable ["RYD_WS_InitCrew",[0,0,0]];
					_eD = _iC select 0;
					_eG = _iC select 1;
					_eC = _iC select 2;
										
					if (_eG == 0) then
						{
						_crw = gunner _vh;
						if not (isNull _crw) then
							{
							if not (_crw == (leader _newGrp)) then
								{
								_unit = _imp select 0;
								_imp = _imp - [_unit];
								deleteVehicle _crw;
								_unit moveInGunner _vh
								}
							}					
						};
						
					if not ((count _imp) > 0) exitWith {};

					if (_eC == 0) then
						{
						_crw = commander _vh;
						if not (isNull _crw) then
							{
							if not (_crw == (leader _newGrp)) then
								{
								_unit = _imp select 0;
								_imp = _imp - [_unit];
								deleteVehicle _crw;
								_unit moveInCommander _vh
								}
							}							
						};
						
					if not ((count _imp) > 0) exitWith {};
					
					if (_eD == 0) then
						{
						_crw = driver _vh;
						if not (isNull _crw) then
							{
							if not (_crw == (leader _newGrp)) then
								{
								_unit = _imp select 0;
								_imp = _imp - [_unit];
								deleteVehicle _crw;
								_unit moveInDriver _vh;
								_newGrp addVehicle _vh 
								}
							}					
						};
						
					if not ((count _imp) > 0) exitWith {};
					}
				foreach _ourVehs
				};
			
				{
				if (_x == (vehicle _x)) then
					{
					deleteVehicle _x
					}
				}
			foreach (units _newGrp)
			};
		};
				
	_newGrp setVariable ["RYD_WS_GroupCount",{alive _x} count (units _newGrp)];
	
	[_newGrp] call RYD_WPdel;
	
	if (RYD_WS_Debug) then
		{
		_ic = "EMark_" + (str _newGrp);
		_ic = createMarker [_ic,position (leader _newGrp)];
		_ic setMarkerColor "colorBlue";
		_ic setMarkerShape "ICON";
		_ic setMarkerType "mil_triangle";
		_ic setMarkerSize [0.6,0.6];
		_newGrp setVariable ["mymarker",_ic];
		_ic setMarkerText (str _azimuth);
		};
		
	if ((count _this) < 5) then
		{	
		_checked = [];
		
			{
			_vh = vehicle _x;
			
			if not (_vh in _checked) then
				{
				_checked set [(count _checked),_vh];
				
				if not (_vh == _x) then
					{
						{
						_x enableSimulation false;
						_x hideObject true
						}
					foreach (crew _vh)
					};
				
				_vh enableSimulation false;
				_vh hideObject true
				}
			}
		foreach (units _newGrp);
		};

	_newGrp
	};
	
RYD_WS_SelectImportant = 
	{
	private ["_units","_important"];
	
	_units = _this select 0;
	
	if ((count _units) < 1) exitWith {[]};

	_important = [leader (group (_units select 0))];
		
	_units = _units - [(leader (group (_units select 0)))];
	
		{
		if not (isNull (unitBackPack _x)) then
			{
			_important set [(count _important),_x]
			};
		}
	foreach _units;
	
	_important
	};
	
RYD_WS_WindRose = 
	{
	private ["_dir","_dirName"];
	
	_dir = _this select 0;
	
	if (_dir < 0) then {_dir = _dir + 360};
	
	_dirName = "";
	
	switch (true) do
		{
		case ((_dir >= 337.5) or (_dir < 22.5)) : {_dirName = "north"};
		case ((_dir < 67.5) and (_dir >= 22.5)) : {_dirName = "north-east"};
		case ((_dir < 112.5) and (_dir >= 67.5)) : {_dirName = "east"};
		case ((_dir < 157.5) and (_dir >= 112.5)) : {_dirName = "south-east"};
		case ((_dir < 202.5) and (_dir >= 157.5)) : {_dirName = "south"};
		case ((_dir < 247.5) and (_dir >= 202.5)) : {_dirName = "south-west"};
		case ((_dir < 292.5) and (_dir >= 247.5)) : {_dirName = "west"};
		case ((_dir < 337.5) and (_dir >= 292.5)) : {_dirName = "north-west"};
		};
		
	_dirName = "the " + _dirName;
		
	_dirName
	};
	
RYD_WS_SpawnAir = 
	{
	private ["_pos","_angle","_classPool","_gp","_dst","_checkPos","_fe","_ct","_vh","_posS","_class","_cl"];
	
	_pos = _this select 0;
	_angle = _this select 1;
	_classPool = _this select 2;
	
	_gp = grpNull;
	
	_dst = 300 - (random 200);

	_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

	_fe = (count (_checkPos isflatempty [20,0,0.1,10,0,false,objNull])) > 0;
	_nR = _checkPos nearRoads 50;
	if ((count _nR) > 0) then {_fe = false};
	
	if (_fe) then
		{
		_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
		if ((_cl distance _checkPos) < 12) then 
			{
			_fe = false
			}
		else
			{
			_fe = [_checkPos] call RYD_WS_isOnMap;
			}
		};
	
	_ct = 0;
	
	while {(not (_fe) or {isOnRoad _checkPos})} do
		{
		_ct = _ct + 1;
		if (_ct > 50) exitWith {};
		_dst = _dst + 5;
		_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

		_fe = (count (_checkPos isflatempty [20,0,0.1,10,0,false,objNull])) > 0;
		_nR = _checkPos nearRoads 50;
		if ((count _nR) > 0) then {_fe = false};
		
		if (_fe) then
			{
			_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
			if ((_cl distance _checkPos) < 12) then 
				{
				_fe = false
				}
			else
				{
				_fe = [_checkPos] call RYD_WS_isOnMap;
				}
			};
		};
		
	if (_fe) then
		{
		_class = selectRandom _classPool;
		
		_ldrs = +(_this select 3);
		
		_allF = 1;
		_ldrArr = [];
		
			{
			_allF = _allF + ((group _x) getVariable ["RYD_WS_mySupport",0]);			
			}
		foreach _ldrs;
		
		_faction = configFile >> "CfgVehicles" >> _class >> "faction";
		_faction = if (isText _faction) then
			{
			(toLower (getText _faction))
			}
		else
			{
			""
			};
		
			{
			_myFacs = (group _x) getVariable ["RydHQ_MyFactions",[""]];
			if (_faction in _myFacs) then
				{
				_ldrArr pushBack _x;
				_ldrArr pushBack (_allF/(((group _x) getVariable ["RYD_WS_mySupport",0]) + 1))
				}
			}
		foreach _ldrs;

		_ldr = selectRandomWeighted _ldrArr;		
		_vh = createVehicle [_class, _checkPos, [], 0, "NONE"];
		
		RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_checkPos];

		_vh setDir _angle;
		_vh setPos _checkPos;
		_vh setVectorUP (surfaceNormal [_checkPos select 0,_checkPos select 1]);
		
		createVehicleCrew _vh;
		_gp = (group _vh);
		_currentForces = (group _ldr) getVariable ["RYD_WS_myAirSupport",0];
		(group _ldr) setVariable ["RYD_WS_myAirSupport",(_currentForces + 1)];
		
		if (RYD_WS_WholeMap) then
			{
			switch (_ldr) do
				{
				case (LeaderHQ) : {RydHQ_Included pushBack _gp};
				case (LeaderHQB) : {RydHQB_Included pushBack _gp};
				case (LeaderHQC) : {RydHQC_Included pushBack _gp};
				case (LeaderHQD) : {RydHQD_Included pushBack _gp};
				//case (LeaderHQE) : {RydHQE_Included pushBack _gp};
				//case (LeaderHQF) : {RydHQF_Included pushBack _gp};
				};
			};
		};
		
	_gp
	};
	
RYD_WS_SpawnStatic = 
	{
	private ["_pos","_angle","_classPool","_gp","_dst","_checkPos","_LOSpos","_isLOS","_fe","_ct","_vh","_posS","_class","_ep","_bags","_cl"];
	
	_pos = _this select 0;
	_angle = _this select 1;
	_classPool = _this select 2;
	
	_gp = grpNull;
	
	_dst = 300 - (random 200);

	_checkPos = [_pos,_angle + 45 - (random 90),_dst] call RYD_PosTowards2D;
	
	_LOSpos = ATLtoASL ([_checkPos,_angle,50] call RYD_PosTowards2D);
	_isLOS = [ATLtoASL _checkPos,_LOSpos,1.5,1.5] call RYD_WS_LOSCheck;
	_fe = (count (_checkPos isflatempty [3,0,0.5,3,0,false,objNull])) > 0;
	
	if (_fe) then
		{
		_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
		if ((_cl distance _checkPos) < 12) then 
			{
			_fe = false
			}
		else
			{
			_fe = [_checkPos] call RYD_WS_isOnMap;
			}
		};
	
	_ct = 0;
	
	while {(not (_isLOS) or not (_fe) or {isOnRoad _checkPos})} do
		{
		_ct = _ct + 1;
		if (_ct > 50) exitWith {};
		_dst = _dst + 5;
		_checkPos = [_pos,_angle + 45 - (random 90),_dst] call RYD_PosTowards2D;
		_checkPos = [_checkPos,0,_ct/2] call RYD_RandomAroundMM;
		_LOSpos = ATLtoASL ([_checkPos,_angle,50] call RYD_PosTowards2D);
		_isLOS = [ATLtoASL _checkPos,_LOSpos,1.5,1.5] call RYD_WS_LOSCheck;
		_fe = (count (_checkPos isFlatEmpty [3,0,0.5,3,0,false,objNull])) > 0;
		
		if (_fe) then
			{
			_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
			if ((_cl distance _checkPos) < 12) then 
				{
				_fe = false
				}
			else
				{
				_fe = [_checkPos] call RYD_WS_isOnMap;
				}
			};
		};
		
	if (_isLOS) then
		{
		if (_fe) then
			{
			_vh = createVehicle ["Land_BagFence_Round_F", _checkPos, [], 0, "NONE"];
			_bags = _vh;
			_vh setDir (_angle + 180);
			_posS = getPos _vh;
			_posS set [2,-0.01];
			_vh setPos _posS;
			_vh setVectorUP (surfaceNormal [_posS select 0,_posS select 1]);
			
			_posS = _vh modelToWorld [0,0.5,0];
			_posS set [2,0];
			
			_LOSpos set [2,1.5];

			_class = selectRandom _classPool;
			
			_ldrs = +(_this select 3);
			
			_allF = 1;
			_ldrArr = [];
			
				{
				_allF = _allF + ((group _x) getVariable ["RYD_WS_mySupport",0]);			
				}
			foreach _ldrs;
			
			_faction = configFile >> "CfgVehicles" >> _class >> "faction";
			_faction = if (isText _faction) then
				{
				(toLower (getText _faction))
				}
			else
				{
				""
				};
			
				{
				_myFacs = (group _x) getVariable ["RydHQ_MyFactions",[""]];
				
				if (_faction in _myFacs) then
					{
					_ldrArr pushBack _x;
					_ldrArr pushBack (_allF/(((group _x) getVariable ["RYD_WS_mySupport",0]) + 1))
					}
				}
			foreach _ldrs;
			
			_ldr = selectRandomWeighted _ldrArr;
			
			_vh = createVehicle [_class, _posS, [], 0, "NONE"];
			
			RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_posS];
			
			_vh setDir _angle;
			_vh setPos _posS;
			_vh setVectorUP (surfaceNormal [_posS select 0,_posS select 1]);
			
			createVehicleCrew _vh;
			
				{
				_x doWatch _LOSpos
				}
			foreach (crew _vh);
			
			_gp = (group _vh);
			_currentForces = (group _ldr) getVariable ["RYD_WS_myStatic",0];
			(group _ldr) setVariable ["RYD_WS_myStatic",(_currentForces + 1)];
			
			if (RYD_WS_WholeMap) then
				{
				switch (_ldr) do
					{
					case (LeaderHQ) : {RydHQ_Included pushBack _gp};
					case (LeaderHQB) : {RydHQB_Included pushBack _gp};
					case (LeaderHQC) : {RydHQC_Included pushBack _gp};
					case (LeaderHQD) : {RydHQD_Included pushBack _gp};
					//case (LeaderHQE) : {RydHQE_Included pushBack _gp};
					//case (LeaderHQF) : {RydHQF_Included pushBack _gp};
					};
				};
			
			_ep = (ASLtoATL (eyePos _vh)) select 2;
			
			if (_ep < 0.8) then {deleteVehicle _bags};
			}
		};
		
	_gp
	};
	
RYD_WS_SpawnSupport =
	{
	private ["_pos","_angle","_classPool","_gp","_dst","_checkPos","_fe","_ct","_vh","_posS","_class","_cl"];
	
	_pos = _this select 0;
	_angle = _this select 1;
	_classPool = _this select 2;
	
	_gp = grpNull;
	
	_dst = 200 - (random 150);

	_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

	_fe = (count (_checkPos isflatempty [6,0,2,10,0,false,objNull])) > 0;
	
	if (_fe) then
		{
		_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
		if ((_cl distance _checkPos) < 12) then 
			{
			_fe = false
			}
		else
			{
			_fe = [_checkPos] call RYD_WS_isOnMap;
			}
		};
	
	_ct = 0;
	
	while {(not (_fe) or {isOnRoad _checkPos})} do
		{
		_ct = _ct + 1;
		if (_ct > 50) exitWith {};
		_dst = _dst + 5;
		_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

		_fe = (count (_checkPos isflatempty [6,0,2,10,0,false,objNull])) > 0;
		
		if (_fe) then
			{
			_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
			if ((_cl distance _checkPos) < 12) then 
				{
				_fe = false
				}
			else
				{
				_fe = [_checkPos] call RYD_WS_isOnMap;
				}
			};
		};
		
	if (_fe) then
		{
		_class = selectRandom _classPool;
		
		_ldrs = +(_this select 3);
		
		_allF = 1;
		_ldrArr = [];
		
			{
			_allF = _allF + ((group _x) getVariable ["RYD_WS_mySupport",0]);			
			}
		foreach _ldrs;
		
		_faction = configFile >> "CfgVehicles" >> _class >> "faction";
		_faction = if (isText _faction) then
			{
			(toLower (getText _faction))
			}
		else
			{
			""
			};
		
			{
			_myFacs = (group _x) getVariable ["RydHQ_MyFactions",[""]];

			if (_faction in _myFacs) then
				{
				_ldrArr pushBack _x;
				_ldrArr pushBack (_allF/(((group _x) getVariable ["RYD_WS_mySupport",0]) + 1))
				}
			}
		foreach _ldrs;
		
		_ldr = selectRandomWeighted _ldrArr;
		
		_vh = createVehicle [_class, _checkPos, [], 0, "NONE"];
		
		if ((toLower _class) in (RYD_WS_ammo + RHQ_Ammo)) then
			{
			_side = getNumber (configFile >> "CfgVehicles" >> _class >> "side");
			
			_side = switch (_side) do
				{
				case (0) : {east};
				case (1) : {west};
				case (2) : {resistance};
				};

			_magsP = ["1Rnd_HE_Grenade_shell","HandGrenade"];
			_magsS = [];
			_wpClass = configFile >> "CfgWeapons";
			
				{
				if ((side _x) == _side) then
					{
					_wpn = primaryWeapon _x;
					if not (_wpn in [""]) then
						{
						_mgs = getArray (_wpClass >> _wpn >> "magazines");
						
						if ((count _mgs) > 0) then
							{
							_mg = _mgs select 0;
							
							if not (_mg in _magsP) then
								{
								_magsP set [(count _magsP),_mg]
								}
							}
						};
						
					_wpn = secondaryWeapon _x;
					if not (_wpn in [""]) then
						{
						_mgs = getArray (_wpClass >> _wpn >> "magazines");
						
						if ((count _mgs) > 0) then
							{
							_mg = _mgs select 0;
							
							if not (_mg in _magsS) then
								{
								_magsS set [(count _magsS),_mg]
								}
							}
						}
					}
				}
			foreach allUnits;
			
				{
				_vh addMagazineCargo [_x, 100 + (random 40)];
				}
			foreach _magsP;
			
				{
				_vh addMagazineCargo [_x, 32 + (random 24)];
				}
			foreach _magsS;
			};
		
		RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_checkPos];

		_vh setDir _angle;
		_vh setPos _checkPos;
		_vh setVectorUP (surfaceNormal [_checkPos select 0,_checkPos select 1]);
		
		createVehicleCrew _vh;
		_gp = (group _vh);
		_currentForces = (group _ldr) getVariable ["RYD_WS_mySupport",0];
		(group _ldr) setVariable ["RYD_WS_mySupport",(_currentForces + 1)];
		
		if (RYD_WS_WholeMap) then
			{
			switch (_ldr) do
				{
				case (LeaderHQ) : {RydHQ_Included pushBack _gp};
				case (LeaderHQB) : {RydHQB_Included pushBack _gp};
				case (LeaderHQC) : {RydHQC_Included pushBack _gp};
				case (LeaderHQD) : {RydHQD_Included pushBack _gp};
				//case (LeaderHQE) : {RydHQE_Included pushBack _gp};
				//case (LeaderHQF) : {RydHQF_Included pushBack _gp};
				};
			};
		};
		
	_gp
	};
	
RYD_WS_LOSCheck = 
	{
	private ["_pos1","_pos2","_tint","_lint","_isLOS","_cam","_target","_pX1","_pY1","_pX2","_pY2","_pos1ATL","_pos2ATL","_level1","_level2"];

	_pos1 = _this select 0;
	_pos2 = _this select 1;
	_level1 = _this select 2;
	_level2 = _this select 3;

	_pX1 = _pos1 select 0;
	_pY1 = _pos1 select 1;

	_pX2 = _pos2 select 0;
	_pY2 = _pos2 select 1;
	
	_pos1 = [_pX1,_pY1,(_pos1 select 2) + _level1];
	_pos2 = [_pX2,_pY2,(_pos2 select 2) + _level2];

	_pos1ATL = [_pX1,_pY1,_level1];
	_pos2ATL = [_pX2,_pY2,_level2];

	_cam = objNull;

	if ((count _this) > 4) then {_cam = _this select 4};

	_target = objNull;

	if ((count _this) > 5) then {_target = _this select 5};

	_tint = terrainintersect [_pos1ATL, _pos2ATL]; 
	_lint = lineintersects [_pos1, _pos2,_cam,_target]; 

	_isLOS = true;

	if ((_tint) or (_lint)) then {_isLOS = false};

	_isLOS
	};
	
RYD_WS_NewRole = 
	{
	_pool = +RYD_WS_ForcesA;
	
		{
		switch (true) do
			{
			case (isNil {_x}) : {_pool set [_foreachIndex,0]};
			case not ((typeName _x) in [typename objNull]) : {_pool set [_foreachIndex,0]};
			case (isNull _x) : {_pool set [_foreachIndex,0]};
			case not (alive _x) : {_pool set [_foreachIndex,0]};
			}
		}
	foreach _pool;
	
	_pool = _pool - [0,player];
	
	if ((count _pool) > 0) then
		{
		selectPlayer (_pool select (floor (random (count _pool))));
		}
	};
	
RYD_TerraCognita = 
	{
	private ["_position","_posX","_posY","_radius","_precision","_sourcesCount","_urban","_forest","_hills","_flat","_sea","_valS","_value","_val0","_samples","_sGr","_hprev","_hcurr","_samplePos","_i","_rds"];	

	_position = _this select 0;
	_samples = _this select 1;
	_rds = 100;
	if ((count _this) > 2) then {_rds = _this select 2};

	if not ((typeName _position) == "ARRAY") then {_position = getPosATL _position};

	_posX = _position select 0;
	_posY = _position select 1;

	_radius = 5;
	_precision = 1;
	_sourcesCount = 1;

	_urban = 0;
	_forest = 0;
	_hills = 0;
	_flat = 0;
	_sea = 0;

	_sGr = 0;
	_hprev = getTerrainHeightASL [_posX,_posY];

	for "_i" from 1 to 10 do
		{
		_samplePos = [_posX + ((random (_rds * 2)) - _rds),_posY + ((random (_rds * 2)) - _rds)];
		_hcurr = getTerrainHeightASL _samplePos;
		_sGr = _sGr + abs (_hcurr - _hprev)
		};

	_sGr = _sGr/10;

		{
		_valS = 0;

		for "_i" from 1 to _samples do
			{
			_position = [_posX + (random (_rds/5)) - (_rds/10),_posY + (random (_rds/5)) - (_rds/10)];


			_value = selectBestPlaces [_position,_radius,_x,_precision,_sourcesCount];

			_val0 = _value select 0;
			_val0 = _val0 select 1;

			_valS = _valS + _val0;
			};

		_valS = _valS/_samples;

		switch (_x) do
			{
			case ("Houses") : {_urban = _urban + _valS};
			case ("Trees") : {_forest = _forest + (_valS/3)};
			case ("Forest") : {_forest = _forest + _valS};
			case ("Hills") : {_hills = _hills + _valS};
			case ("Meadow") : {_flat = _flat + _valS};
			case ("Sea") : {_sea = _sea + _valS};
			};
		}
	foreach ["Houses","Trees","Forest","Hills","Meadow","Sea"];

	[_urban,_forest,_hills,_flat,_sea,_sGr]
	};
	
RYD_Sectorize = 
	{
	private ["_ctr","_lng","_ang","_nbr","_EdgeL","_rd","_main","_step","_X1","_Y1","_posX","_posY","_centers","_first",
	"_sectors","_centers2","_Xa","_Ya","_dXa","_dYa","_dst","_ang2","_Xb","_Yb","_dXb","_dYb","_center","_crX","_crY","_crPoint","_sec"];

	_ctr = _this select 0;
	_lng = _this select 1;
	_ang = _this select 2;
	_nbr = _this select 3;

	_EdgeL = _lng/_nbr;
	
	_rd = _lng/2;

	_main = createLocation ["Name", _ctr, _rd, _rd];
	_main setRectangular true;

	_step = _EdgeL;

	_X1 = _ctr select 0;
	_Y1 = _ctr select 1;

	_posX = (_X1 - _rd) + _step/2;
	_posY = (_Y1 - _rd) + _step/2;

	_centers = [[_posX,_posY]];
	_first = false;

	while {(true)} do
		{
		while {(true)} do
			{
			if not (_first) then {_first = true;_posX = _posX + _step};
			if not ([_posX,_PosY] in _main) exitwith {_posX = ((_ctr select 0) - _rd) + _step/2;_first = true};
			_centers set [(count _centers),[_posX,_PosY]];
			_first = false
			};
		_posY = _posY + _step;
		if not ([_posX,_PosY] in _main) exitwith {}
		};

	if not (_ang in [0,90,180,270]) then
		{
		_main setDirection _ang;
		_centers2 = +_centers;
		_centers = [];

			{
			_Xa = _x select 0;
			_Ya = _x select 1;
			_dXa = (_X1 - _Xa);
			_dYa = (_Y1 - _Ya);
			_dst = _ctr distance _x;

			_ang2 = _ang + (_dXa atan2 _dYa);

			_dXb = _dst * (sin _ang2);
			_dYb = _dst * (cos _ang2);

			_Xb = _X1 + _dXb;
			_Yb = _Y1 + _dYb;
			_center = [_Xb,_Yb];
			_centers set [(count _centers),_center]
			}
		foreach _centers2
		};
	
	_sectors = [];

		{
		_crX = _x select 0;
		_crY = _x select 1;
		_crPoint = [_crX,_crY,0];
		_sec = createLocation ["Name", _crPoint, _EdgeL/2, _EdgeL/2];
		_sec setDirection _ang;
		_sec setRectangular true;

		_sectors set [(count _sectors),_sec];
		}
	foreach _centers;

	[_sectors,_main]	
	};
			
RYD_AngTowards = 
	{
	private ["_source0","_target0","_rnd0","_dX0","_dY0","_angleAzimuth0"];
	
	_source0 = _this select 0;
	_target0 = _this select 1;
	_rnd0 = _this select 2;

	_dX0 = (_target0 select 0) - (_source0 select 0);
	_dY0 = (_target0 select 1) - (_source0 select 1);

	_angleAzimuth0 = (_dX0 atan2 _dY0) + (random (_rnd0 * 2)) - _rnd0;

	_angleAzimuth0
	};
	
RYD_PosTowards2D = 
	{
	private ["_source","_distT","_angle","_dXb","_dYb","_px","_py","_pz"];

	_source = _this select 0;
	_angle = _this select 1;
	_distT = _this select 2;

	_dXb = _distT * (sin _angle);
	_dYb = _distT * (cos _angle);

	_px = (_source select 0) + _dXb;
	_py = (_source select 1) + _dYb;

	_pz = getTerrainHeightASL [_px,_py];

	[_px,_py,_pz]
	};
	
RYD_RandomAroundMM = 
	{//based on Muzzleflash' function
	private ["_pos","_xPos","_yPos","_a","_b","_dir","_angle","_mag","_nX","_nY","_temp"];

	_pos = _this select 0;
	_a = _this select 1;
	_b = _this select 2;
	
	_b = _b - _a;

	_xPos = _pos select 0;
	_yPos = _pos select 1;

	_dir = random 360;

	_mag = _a + (sqrt ((random _b) * _b));
	_nX = _mag * (sin _dir);
	_nY = _mag * (cos _dir);

	_pos = [_xPos + _nX, _yPos + _nY,0];  

	_pos	
	};
	
RYD_WPdel = 
	{//[_gp] call RYD_WPdel
	private ["_gp","_count"];

	_gp = _this select 0;

	if (isNil "_gp") exitWith {};
	if (isNull _gp) exitWith {};

	_count = (count (waypoints _gp)) - 1;

	if (_count < 0) exitWith {};

	[_gp, (currentWaypoint _gp)] setWaypointPosition [position (vehicle (leader _gp)), 0];

	while {not (_count < 0)} do
		{
		if (isNull _gp) exitWith {};
		_count = (count (waypoints _gp)) - 1;
		if (_count < 0) exitWith {};
		deleteWaypoint ((waypoints _gp) select _count);
		_count = (count (waypoints _gp)) - 1
		}
	};
	
RYD_WS_FindClosest = 
	{
	private ["_ref","_objects","_closest","_dstMin","_dstAct","_obj"];

	_ref = _this select 0;
	_objects = _this select 1;

	_closest = objNull;

	if ((count _objects) > 0) then 
		{
		_closest = _objects select 0;
		_obj = _closest;
	
		_dstMin = _ref distance _obj;

			{
			_obj = _x;				
			_dstAct = _ref distance _obj;

			if (_dstAct < _dstMin) then
				{
				_closest = _x;
				_dstMin = _dstAct
				}
			}
		foreach _objects
		};

	_closest
	};
	
RYD_WS_Findfarthest = 
	{
	private ["_ref","_objects","_farthest","_dstMax","_dstAct","_obj"];

	_ref = _this select 0;
	_objects = _this select 1;

	_farthest = objNull;

	if ((count _objects) > 0) then 
		{
		_farthest = _objects select 0;
		_obj = _farthest;
	
		_dstMax = _ref distance _obj;

			{
			_obj = _x;				
			_dstAct = _ref distance _obj;

			if (_dstAct > _dstMax) then
				{
				_farthest = _x;
				_dstMax = _dstAct
				}
			}
		foreach _objects
		};

	_farthest
	};
	
RYD_WS_FindClosest2D = 
	{
	private ["_ref","_objects","_closest","_dstMin","_dstAct","_obj"];

	_ref = _this select 0;
	_objects = _this select 1;

	_closest = objNull;

	if ((count _objects) > 0) then 
		{
		_closest = _objects select 0;
		_obj = _closest;
	
		_dstMin = _ref distance2D (position _obj);

			{
			_obj = _x;				
			_dstAct = _ref distance2D (position _obj);

			if (_dstAct < _dstMin) then
				{
				_closest = _x;
				_dstMin = _dstAct
				}
			}
		foreach _objects
		};

	_closest
	};
	
RYD_WS_FindFarthest2D = 
	{
	private ["_ref","_objects","_farthest","_dstMax","_dstAct","_obj"];

	_ref = _this select 0;
	_objects = _this select 1;

	_farthest = objNull;

	if ((count _objects) > 0) then 
		{
		_farthest = _objects select 0;
		_obj = _farthest;
	
		_dstMax = _ref distance2D (position _obj);

			{
			_obj = _x;				
			_dstAct = _ref distance2D (position _obj);

			if (_dstAct > _dstMax) then
				{
				_farthest = _x;
				_dstMax = _dstAct
				}
			}
		foreach _objects
		};

	_farthest
	};
	
RYD_WS_MARTASwitch = 
	{
	switch (RYD_WS_Marta) do
		{
		case (false) :
			{
			RYD_WS_Marta = true;
			hint "Military symbols enabled";
			
				/*{
				_x setVariable ["MARTA_showRules",[(RYD_WS_FacA select 1),1,(RYD_WS_FacB select 1),0]];
				}
			foreach RYD_WS_ForcesA;*/
			
			setGroupIconsVisible [true,false];
			};
			
		case (true) :
			{
			RYD_WS_Marta = false;
			hint "Military symbols disabled";
			
				/*{
				_x setVariable ["MARTA_showRules",[(RYD_WS_FacA select 1),-1,(RYD_WS_FacB select 1),-1]];
				}
			foreach RYD_WS_ForcesA;*/
			
			setGroupIconsVisible [false,false];
			};
		}
	};
	
RYD_BIS_fnc_typeText = 
	{
	/*
		Author: Jiri Wainar

		Description:
		Types a structured text on the screen, letter by letter, cursor blinking.

		Parameter(s):
		_this: array containing blocks of text with same structured text formatting

		Remarks:
		* Every text block is an array of text and formatting tag.
		* Blocks don't have to span over whole line.

		Example:

		[
			["CAMP ROGAIN,","<t align = 'center' shadow = '1' size = '0.7' font='PuristaBold'>%1</t>"],
			["RESSUPLY POINT","<t align = 'center' shadow = '1' size = '0.7'>%1</t><br/>"],
			["10 MINUTES LATER ...","<t align = 'center' shadow = '1' size = '1.0'>%1</t><br/>"]

		] spawn BIS_fnc_typeText;
	*/

	#define DELAY_CHARACTER	0.06;
	#define DELAY_CURSOR	0.04;

	private["_data","_posX","_posY","_rootFormat","_toDisplay"];
	private["_blocks","_block","_blockCount","_blockNr","_blockArray","_blockText","_blockTextF","_blockTextF_","_blockFormat","_formats","_inputData","_processedTextF","_char","_cursorInvis","_blinkCounts","_blinkCount"];

	_data 		= [_this, 0, [], [[]]] call BIS_fnc_param;
	_posX 		= [_this, 1, 0, [123]] call BIS_fnc_param;
	_posY 		= [_this, 2, 0, [123]] call BIS_fnc_param;
	_rootFormat 	= [_this, 3, "<t >%1</t>", [""]] call BIS_fnc_param;

	_blockCount = count _data;

	_invisCursor = "<t color ='#00000000' shadow = '0'>_</t>";

	//process the input data
	_blocks 	= [];
	_formats 	= [];
	_blinkCounts 	= [];

	{
		_inputData = _x;

		_block 		= [_inputData, 0, "", [""]] call BIS_fnc_param;
		_format 	= [_inputData, 1, "<t align = 'center' shadow = '1' size = '0.7'>%1</t><br/>", [""]] call BIS_fnc_param;
		_blinkCount 	= [_inputData, 2, 5, [123]] call BIS_fnc_param;

		//convert strings into array of chars
		_blockArray = toArray _block;
		{_blockArray set [_forEachIndex, toString [_x]]} forEach _blockArray;

		_blocks  = _blocks + [_blockArray];
		_formats = _formats + [_format];
		_blinkCounts = _blinkCounts + [_blinkCount];
	}
	forEach _data;

	//do the printing
	_processedTextF  = "";

	{
		_blockArray  = _x;
		_blockNr     = _forEachIndex;
		_blockFormat = _formats select _blockNr;
		_blockText   = "";
		_blockTextF  = "";
		_blockTextF_ = "";

		{
			_char = _x;

			_blockText = _blockText + _char;

			_blockTextF  = format[_blockFormat, _blockText + _invisCursor];
			_blockTextF_ = format[_blockFormat, _blockText + "_"];

			//print the output
			_toDisplay = format[_rootFormat,_processedTextF + _blockTextF_];
			[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;

			playSound "ReadoutClick";

			sleep DELAY_CHARACTER;
			_toDisplay = format[_rootFormat,_processedTextF + _blockTextF];
			[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
			sleep DELAY_CURSOR;
		}
		forEach _blockArray;

		_blinkCount = _blinkCounts select _forEachIndex;

		if (_blinkCount > 0) then
		{
			for "_i" from 1 to _blinkCount do
			{
				_toDisplay = format[_rootFormat,_processedTextF + _blockTextF_];
				[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
				sleep DELAY_CHARACTER;
				_toDisplay = format[_rootFormat,_processedTextF + _blockTextF];
				[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
				sleep DELAY_CURSOR;
			};
		};

		//store finished block
		_processedTextF  = _processedTextF + _blockTextF;
	}
	forEach _blocks;
	
	RYD_WS_Typed = true;
	
	sleep 5;

	//clean the screen
	["", _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
	};
	
RYD_WS_ClusterMark = 
	{
	private ["_gps","_cl","_brush","_midX","_midY","_cluster","_pos","_center","_pointMax","_dstMax","_ix","_dstAct","_angle","_dstMax2","_mark"];
	
	_gps = _this select 0;
	_cl = _this select 1;
	_brush = _this select 2;
	
	_midX = 0;
	_midY = 0;

	_cluster = [];

		{
		_pos = position (leader _x);
		_pos set [2,0];
		_cluster set [(count _cluster),_pos]
		}
	foreach _gps;

		{
		_midX = _midX + (_x select 0);
		_midY = _midY + (_x select 1);
		}
	foreach _cluster;

	_center = [_midX/(count _cluster),_midY/(count _cluster),0];

	_pointMax = _center;
	_dstMax = 0;
	_ix = 0;

		{
		_dstAct = _center distance _x;
		if (_dstAct > _dstMax) then
			{
			_dstMax = _dstAct;
			_pointMax = _x;
			_ix = _foreachIndex
			}
		}
	foreach _cluster;

	_cluster set [_ix,-1];
	_cluster = _cluster - [-1];

	_angle = [_center,_pointMax,0] call RYD_AngTowards;

	_pointMax = _center;
	_dstMax2 = 0;

		{
		_dstAct = _center distance _x;
		if (_dstAct > _dstMax2) then
			{
			_dstMax2 = _dstAct;
			_pointMax = _x;
			}
		}
	foreach _cluster;

	_mark = ["Per_" + _cl,_center,_cl,"ELLIPSE",[_dstMax,_dstMax2],_angle + 90,1,"FDiagonal",""] call RYD_Marker;
	
	_mark
	};
	
RYD_WS_onHit = 
	{
	private ["_hit"];
	
	_hit = _this select 0;
	
	if (_hit in RYD_WS_Wounded_A) exitWith {};
	
	RYD_WS_Wounded_A set [(count RYD_WS_Wounded_A),_hit];
	};
	
RYD_WS_onDeathA = 
	{
	private ["_kia","_killer","_KIAs"];
	
	_kia = _this select 0;
	_killer = _this select 1;

	if (_killer getVariable ["RYD_WS_Aside",false]) then {_killer setVariable ["RYD_WS_Indicted",true]};
	
	if (_kia in RYD_WS_Killed_A) exitWith {};
	
	RYD_WS_Killed_A set [(count RYD_WS_Killed_A),_kia];
		
	_KIAs = missionNamespace getVariable ["WS_KIA_A",[]];
	
	_KIAs set [(count _KIAs),(_kia getVariable ["WS_myName",name _kia])];
	
	missionNamespace setVariable ["WS_KIA_A",_KIAs];
	};
	
RYD_WS_onDeathB = 
	{
	private ["_kia","_killer","_KIAs"];
	
	_kia = _this select 0;
	_killer = _this select 1;
		
	//diag_log format ["kia: %1 killer: %2, name: %3 real name: %4",_kia,_killer,name _killer,(_killer getVariable ["WS_myName",name _killer])];
	
	if not (_killer getVariable ["RYD_WS_Aside",false]) exitWith {};
	if (_kia in RYD_WS_Killed_B) exitWith {};
	
	RYD_WS_Killed_B set [(count RYD_WS_Killed_B),_kia];
	
	_name = _killer getVariable ["WS_myName",name _killer];
	
	_KIAs = missionNamespace getVariable ["WS_KIA_B" + _name,[_name,0]];
		
	_amnt = _KIAs select 1;
	_amnt = _amnt + 1;
	
	//diag_log format ["Kills: %1",_amnt];
	
	missionNamespace setVariable ["WS_KIA_B" + _name,[_name,_amnt]];
	};
	
RYD_WS_SortByKills =
	{
	private ["_arr","_sorted","_highest","_valMax","_ix","_val"];
	
	_arr = _this select 0;
	
	_sorted = [];
	
	while {(count _arr) > 0} do
		{
		_highest = _arr select 0;
		_valMax = _highest select 1;
		_ix = 0;
		
			{
			_val = _x select 1;
			if (_val > _valMax) then
				{
				_valMax = _val;
				_highest = _x;
				_ix = _foreachIndex
				}
			}
		foreach _arr;
		
		_sorted set [(count _sorted),_highest];
		_arr set [_ix,0];
		_arr = _arr - [0]
		}; 
	
	_sorted
	};
	
RYD_WS_FatigueSwitch = 
	{
	switch (RYD_WS_Fatigue) do
		{
		case (true) : 
			{
			RYD_WS_Fatigue = false;
			
				{
				_x enableFatigue false
				} 
			forEach allUnits;
			
			hint "Fatigue effects disabled"
			};
			
		case (false) : 
			{
			RYD_WS_Fatigue = true;
			
				{
				_x enableFatigue true
				} 
			forEach allUnits;
			
			hint "Fatigue effects enabled"
			};
		};
	};
	
RYD_RandomOrdB = 
	{
	private ["_array","_final","_random","_select"];

	_array = _this select 0;

	_final = [];

	while {((count _array) > 0)} do
		{
		_select = floor (random (count _array));
		_random = _array select _select;
		
		if not (isNil "_random") then 
			{
			_final pushBack _random;
			};
			
		_array = _array - [_random];

		//_array set [_select,"Delete"];
		//_array = _array - ["Delete"]
		};

	_final
	};
	
RYD_WS_LandConnectedLine = 
	{
	private ["_connected","_dir","_dst","_actDst"];
	params ["_pos1","_pos2","_step"];
	
	_connected = true;

	_pos1 = [_pos1,5,500] call RYD_WS_FindLandPosNear;
	_pos1 set [2,0];
	_pos2 = [_pos2,5,500] call RYD_WS_FindLandPosNear;
	_pos2 set [2,0];
	_dir = _pos1 getDir _pos2;
	
	_dst = _pos1 distance2D _pos2;
	_actDst = 0;
	for "_i" from 0 to (floor (_dst/_step)) do
		{
		_actDst = _actDst + _step;
		private _pos = (_pos1 getPos [_actDst,_dir]);
		if (surfaceIsWater (_pos1 getPos [_actDst,_dir])) exitWith 
			{
			
/*_mk = (str _pos);
	_mk = createMarker [_mk,_pos];
	_mk setMarkerColor "ColorRed";
	_mk setMarkerShape "ICON";
	_mk setMarkerSize [0.35,0.35];
	_mk setMarkerType "mil_triangle";
	_mk setMarkerDir _dir;	*/			
			
			_connected = false
			};
			
/*_mk = (str _pos);
	_mk = createMarker [_mk,_pos];
	_mk setMarkerColor "ColorGreen";
	_mk setMarkerShape "ICON";
	_mk setMarkerSize [0.35,0.35];
	_mk setMarkerType "mil_triangle";
	_mk setMarkerDir _dir;	*/
		};
		
	_connected
	};
	
//["NameCityCapital","NameCity","NameVillage","NameLocal","Hill"]	
RYD_WS_LandMassLocations = 
	{
	private ["_mapSize","_mapRad","_mapC","_newType","_actTypes2","_actLocs","_type","_newLocs","_addLocs","_allCnt","_newLock","_locWebs","_locWeb","_potentials","_foundNew","_pot","_maxWeb","_maxL","_toRem"];
	params ["_types","_actTypes","_currentLocs","_minLoc","_maxMpl"];
		
	_mapSize = RydBB_MapXMax;//getNumber (configFile >> "CfgWorlds" >> worldName >> "mapSize");
	_mapRad = (_mapSize/2) * (sqrt 2);
	_mapC = +RydBB_MapC;
	
	_allLocs = +_currentLocs;
	_newType = _types select 0;
	_actTypes pushBack _newType;
	_actTypes2 = +_actTypes;
	_types set [0,""];
	_types = _types - [""];
	_maxL = _minLoc * (1 + (random (_maxMpl - 1)));
	_actLocs = [];
	
	while {(((count _actLocs) < _maxL) and {(count _actTypes2) > 0})} do
		{
		_type = _actTypes2 select 0;
		_actTypes2 = _actTypes2 - [_type];
		
		_newLocs0 = (nearestLocations [_mapC,[_type],_mapRad]) - _currentLocs;
		_newLocs = [];
		
		if (not (isNil "RydBB_MC") and {((typeName RydBB_MC) isEqualTo (typeName objNull))}) then
			{
				{
				if ((position _x) inArea RydBB_MC) then
					{
					_newLocs pushBack _x
					}
				}
			foreach _newLocs0
			}
		else
			{
			_newLocs = +_newLocs0
			};
		
		_addLocs = [];
		_allCnt = count _actLocs;

		for "_i" from 1 to (_maxL min (count _newLocs)) do
		//for "_i" from 1 to (count _newLocs) do
			{
			_newLoc = selectRandom _newLocs;
			_newLocs = _newLocs - [_newLoc];
			_addLocs pushBackUnique _newLoc;
			
			if (random ((((count _addLocs) + _allCnt) - _maxL) max 0) > 1) exitWith {};
			};

		_allLocs appEnd _addLocs;
		_actLocs appEnd _addLocs;
		};
		
	//_allLocs = _currentLocs + (_allLocs - _currentLocs); 
	_cnt = count _allLocs;

	_locWebs = [];
	
		{
		_locWeb = [_x];	
		_potentials = _allLocs - _locWeb;
		
		_foundNew = (count _potentials) > 0;
		while {_foundNew} do
			{
			_foundNew = false;
			_pot = locationNull;
			
				{
				_pot = _x;

				if (({([position _pot,position _x,100] call RYD_WS_LandConnectedLine)} count _locWeb) > 0) exitWith
					{
					_locWeb pushBack _pot;
					_foundNew = true;
					}
				}
			foreach _potentials;
			_potentials = _potentials - [_pot];
			};

		_locWebs pushBack _locWeb;
		}
	foreach _allLocs;
	
	_maxWeb = _locWebs call RYD_WS_FindLongestArray;

	_maxWeb = _currentLocs + (_maxWeb - _currentLocs); 
	
	while {((count _maxWeb) > _maxL)} do
		{
		_toRem = selectRandom _maxWeb;
		_maxWeb = _maxWeb - [_toRem]
		};
		
	//diag_log format ["[_actTypes,_cnt,count _maxWeb,_minLoc,_maxL]: %1",[_actTypes,_cnt,count _maxWeb,_minLoc,_maxL]];

	if ((((count _maxWeb) - _maxL) < 0) and {((count _types) > 0)}) then
		{
		([_types,_actTypes,_maxWeb,_min,_maxMpl] call RYD_WS_LandMassLocations)
		}
	else	
		{
		_maxWeb
		}
	};
	
RYD_WS_FindLongestArray = 
	{
	if ((count _this) < 1) exitWith {[]};
	
	private _longestIx = 0;
	private _longest = 0;
	
		{
		private _long = count _x;
		if (_long > _longest) then
			{
			_longest = _long;
			_longestIx = _foreachIndex
			}
		}
	foreach _this;
	
	(_this select _longestIx)
	};
	
RYD_WS_FindLandPosNear = 
		{
		private ["_pos","_dir","_lvl","_mapSize","_notMapCount","_ct","_dst"];
		params ["_fPos","_prec","_limit"];
		
		_pos = +_fPos;
		_dir = random 360;
		_lvl = _pos select 2;
		_mapSize = getNumber (configFile >> "CfgWorlds" >> worldName >> "mapSize");
		_notMapCount = 0;
		_ct = 0;
		_dst = 10 * _prec;
		
		while {((surfaceIsWater _pos) and {(_notMapCount < 360) and {((_limit < 0) or {((_fPos distance2D _pos) <= _limit)})}})} do
			{
			_dir = _dir + 36;
			if (_dir > 360) then
				{
				_dir = _dir - 360;
				_dst = _dst + (10 * _prec)
				};
				
			_pos = _fPos getPos [_dst,_dir];
			if ([_pos] call RYD_WS_isOnMap) then
				{
				//_pos = _nPos;
				_notMapCount = 0;
				}
			else
				{
				_notMapCount = _notMapCount + 36
				};
				
	/*_i = (str _pos);
	_i = createMarker [_i,_pos];
	_i setMarkerColor "ColorBlue";
	_i setMarkerShape "ICON";
	_i setMarkerSize [0.7,0.7];
	_i setMarkerType "mil_triangle";
	_i setMarkerDir _dir;*/
			
			_ct = _ct + 1;
			if (_ct > 1000) exitWith {};
			};
			
		if ((_notMapCount < 360) and {((_limit < 0) or {((_fPos distance2D _pos) <= _limit)})}) then
			{
			_pos
			}
		else
			{
			_fPos
			}
		};
	
RYD_WS_WholeMapPlacement = 
	{	
	_types = ["NameCityCapital","NameCity","NameVillage","NameLocal","Hill"];

	_min = 10;
	_maxMpl = 1.5;
	_locWeb = [_types,[],[],_min,_maxMpl] call RYD_WS_LandMassLocations;

		/*{
		_pos = position _x;
_i = (str _pos);
	_i = createMarker [_i,_pos];
	_i setMarkerColor "ColorBlue";
	_i setMarkerShape "ICON";
	_i setMarkerSize [0.7,0.7];
	_i setMarkerType "mil_box";
		}
	foreach _locWeb;*/

	_web = [];
	_locs = [];
	_locT = [];
	
		{
		_pos = [(position _x),5,500] call RYD_WS_FindLandPosNear;
		if not (surfaceIsWater _pos) then
			{
			_pos set [2,0];
			_web pushBack _pos;
			_locs pushBack _x;
			_locT pushBack (toLower (type _x))
			}
		}
	foreach _locWeb;
	
	_countW = count _web;

	if (_countW < 2) exitWith
		{
		endLoadingScreen;
		hintC "Initialization failed: Not enough relevant locations found";
		sleep 0.1;
		failMission "END1";
		};
	
	_mapRad = (RydBB_MapXMax/2) * (sqrt 2);
	
	_relDir = random 360;
	_relPos = RydBB_MapC getPos [_mapRad,_relDir];
	
	_locA = [_relPos,_locs] call RYD_WS_FindClosest2D;
	
	_chance = 75;
	while {((random 100) < _chance)} do
		{
		_locs = _locs - [_locA];
		if ((count _locs) < 2) exitWith {};
		_locA = [_relPos,_locs] call RYD_WS_FindClosest2D;
		_chance = _chance/1.5;
		};	
	
	_posA = position _locA;
	_posA set [2,0];
	
	_locB = [_posA,(_locs - [_locA])] call RYD_WS_FindFarthest2D;
	_chance = 75;
	while {((random 100) < _chance)} do
		{
		_locs = _locs - [_locB];
		if ((count _locs) < 2) exitWith {};
		_locB = [_posA,(_locs - [_locA])] call RYD_WS_FindFarthest2D;
		_chance = _chance/1.5;
		};
	
	_posB = position _locB;
	_posB set [2,0];
	
	_dirL = _posB getDir _posA;
	_dirL0 = _dirL;
	_relPosB = RydBB_MapC getPos [_mapRad,_dirL + 180];
	
	_cX = 0;
	_cY = 0;
	
		{
		_cX = _cX + (_x select 0);
		_cY = _cY + (_x select 1);
		}
	foreach _web;
	
	_battlefield = [_posA,_posB,[(_cX/_countW),(_cY/_countW)]];
	
	RYD_WS_BFPos = [(_cX/_countW),(_cY/_countW)];
	RYD_WS_BFPos set [2,0];
	
	RYD_WS_BFRadius = (_battlefield select 0) distance (_battlefield select 1);

	_topo = [(_battlefield select 2),RYD_WS_BFRadius] call RYD_WS_Topo;

	_infFr = ((_topo select 0) + (_topo select 1) + (_topo select 2) + (_topo select 4))/100;
	
	_forces = [2,RYD_WS_Scale,[_sideA,_sideB],_infFr] call RYD_WS_Forces;
	
		{
			{
				{
				_sum = _sum + 1
				}
			foreach _x	
			}
		foreach _x
		}
	foreach _forces;
		
		{
		_ldrClassArr = [];
		
		switch (_x) do
			{
			case (west) : 
				{
				_ldrClassArr = RYD_WS_B_Officers_G2;
				if ((count _ldrClassArr) < 1) then
					{
					_ldrClassArr = ["B_officer_F"];
					}
				};
				
			case (east) : 
				{
				_ldrClassArr = RYD_WS_O_Officers_G2;
				if ((count _ldrClassArr) < 1) then
					{
					_ldrClassArr = ["O_officer_F"];
					}
				};
				
			case (resistance) : 
				{
				_ldrClassArr = RYD_WS_I_Officers_G2;
				if ((count _ldrClassArr) < 1) then
					{
					_ldrClassArr = ["I_officer_F"];
					}
				};
			};
								
		_mainPos = if (_foreachIndex == 0) then
			{
			_posA
			}
		else
			{
			_dirL = _dirL + 180;
			_posB
			};
			
		_eyeOfBattle = _battlefield select 2;

		if ((_mainPos distance _eyeOfBattle) < 500) then
			{
			_ix = 0;
			if (_foreachIndex == 0) then
				{
				_ix = 1
				};
				
			_eyeOfBattle = _battlefield select _ix
			};
			
		_dst = _mainPos distance _eyeOfBattle;	
			
		_ldrPositions = [];
		
		for "_i" from 1 to 2 do
			{
			_ldrPos0 = _mainPos getPos [(-1500 + (_i * 1000)),(_dirL + 90)];
			
			_ldrPos0 = [_ldrPos0,_dirL + 180,((_dst/3) min 800) max 500] call RYD_PosTowards2D;
			
			_ldrPos = [_ldrPos0,0,160,5,0,1.5,0,[],[_ldrPos0,_ldrPos0]] call BIS_fnc_findSafePos;
			_fe = not (isOnRoad _ldrPos);
			_nR = _ldrPos nearRoads 50;
			if (((count _nR) > 0) or ((_ldrPos0 distance _ldrPos) > 5000)) then {_fe = false};
			_ct = 0;
			
			while {(not _fe)} do
				{
				_ldrPos = [_ldrPos0,10,100 + (_ct * 5)] call RYD_RandomAroundMM;
				_ldrPos = [_ldrPos,0,160,5,0,1.5,0,[],[_ldrPos,_ldrPos]] call BIS_fnc_findSafePos;
				_ct = _ct + 1;
				if (_ct > 20) exitWith {};
				_fe = not (isOnRoad _ldrPos);
				_nR = _ldrPos nearRoads 50;
				if (((count _nR) > 0) or ((_ldrPos0 distance _ldrPos) > 5000)) then {_fe = false};
				};
				
			if ((surfaceIsWater _ldrPos) or {not ([_ldrPos] call RYD_WS_isOnMap)}) then
				{
				_ldrPos = +_mainPos 
				};
				
			_ldrPositions pushBack _ldrPos;
				
			//_mark = [str (random 1000),_ldrPos,"ColorPink","ICON",[1.25,1.25],0,1,"mil_triangle",""] call RYD_Marker;
			
			};
						
		_sideIx = _foreachIndex;
		
		_facM = switch (_sideIx) do
			{
			case (0) : {RYD_WS_selFactionsA};
			case (1) : {RYD_WS_selFactionsB};
			};			
		
		_side = _x;
		_dir = _dirL + 180;
		
			{		
			_cntL = count _ldrPositions;
			
			switch (_sideIx) do
				{
				case (0) :
					{
					switch (_foreachIndex) do
						{
						case (0) :
							{
							_cntF = count _facM;
							_ldrIx = _foreachIndex + 1;
							_myFactions = [];
							
							if (_cntF > _cntL) then
								{
								for "_i" from _ldrIx to _cntF step _cntL do
									{
									_myFactions pushBack (((_facM select (_i - 1)) select 0) select 0) 
									};
								}
							else
								{
								_facIx = _foreachIndex mod _cntF;
								_myFactions = [(((_facM select _facIx) select 0) select 0)];
								};

							_fac = selectRandom _myFactions;

							_classArr = [];
							
								{
								_cFac = getText (configFile >> "CfgVehicles" >> _x >> "faction");
								if (_fac isEqualTo _cFac) then
									{
									_classArr pushBack _x;
									}
								}
							foreach _ldrClassArr;
							
							if ((count _classArr) < 1) then
								{
								_classArr = _ldrClassArr;
								};
							
							_ldrClass = selectRandom _classArr;							
							_ldrGp = createGroup _side;
							leaderHQ = _ldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
							leaderHQ setDir _dir;
							(group leaderHQ) setVariable ["RydHQ_MyDir",_dir];
							(group leaderHQ) setVariable ["RydHQ_MyFactions",_myFactions];
							
							if (RYD_WS_LeadersPoofItsMagic) then
								{
								removeAllWeapons leaderHQ;
								leaderHQ hideObject true;
								leaderHQ allowDamage false;
								leaderHQ addEventHandler ["HandleDamage",{0}];
							
								_fldrGp = createGroup _side;
								RydHQ_ExcludedG pushback _fldrGp;
								fakeLeaderHQ = _fldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
								fakeLeaderHQ setDir _dir;
								(group fakeLeaderHQ) setVariable ["RydHQ_MyDir",_dir];
								(group fakeLeaderHQ) setVariable ["RydHQ_MyFactions",_myFactions];
								
								[fakeLeaderHQ] call RYD_WS_HQGuard;
								};
							};
							
						case (1) :
							{
							_cntF = count _facM;
							_ldrIx = _foreachIndex + 1;
							_myFactions = [];
							
							if (_cntF > _cntL) then
								{
								for "_i" from _ldrIx to _cntF step _cntL do
									{
									_myFactions pushBack (((_facM select (_i - 1)) select 0) select 0) 
									};
								}
							else
								{
								_facIx = _foreachIndex mod _cntF;
								_myFactions = [(((_facM select _facIx) select 0) select 0)];
								};

							_fac = selectRandom _myFactions;

							_classArr = [];
							
								{
								_cFac = getText (configFile >> "CfgVehicles" >> _x >> "faction");
								if (_fac isEqualTo _cFac) then
									{
									_classArr pushBack _x;
									}
								}
							foreach _ldrClassArr;
							
							if ((count _classArr) < 1) then
								{
								_classArr = _ldrClassArr;
								};
							
							_ldrClass = selectRandom _classArr;
							_ldrGp = createGroup _side;
							leaderHQB = _ldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
							leaderHQB setDir _dir;
							(group leaderHQB) setVariable ["RydHQ_MyDir",_dir];
							(group leaderHQB) setVariable ["RydHQ_MyFactions",_myFactions];	
							
							if (RYD_WS_LeadersPoofItsMagic) then
								{
								removeAllWeapons leaderHQB;
								leaderHQB hideObject true;
								leaderHQB allowDamage false;
								leaderHQB addEventHandler ["HandleDamage",{0}];
							
								_fldrGp = createGroup _side;
								RydHQB_ExcludedG pushback _fldrGp;
								fakeLeaderHQB = _fldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
								fakeLeaderHQB setDir _dir;
								(group fakeLeaderHQB) setVariable ["RydHQ_MyDir",_dir];
								(group fakeLeaderHQB) setVariable ["RydHQ_MyFactions",_myFactions];
								
								[fakeLeaderHQB] call RYD_WS_HQGuard;
								};
							};
							
						/*case (2) :
							{
							_cntF = count _facM;
							_ldrIx = _foreachIndex + 1;
							_myFactions = [];
							
							if (_cntF > _cntL) then
								{
								for "_i" from _ldrIx to _cntF step _cntL do
									{
									_myFactions pushBack (((_facM select (_i - 1)) select 0) select 0) 
									};
								}
							else
								{
								_facIx = _foreachIndex mod _cntF;
								_myFactions = [(((_facM select _facIx) select 0) select 0)];
								};

							_fac = selectRandom _myFactions;

							_classArr = [];
							
								{
								_cFac = getText (configFile >> "CfgVehicles" >> _x >> "faction");
								if (_fac isEqualTo _cFac) then
									{
									_classArr pushBack _x;
									}
								}
							foreach _ldrClassArr;
							
							if ((count _classArr) < 1) then
								{
								_classArr = _ldrClassArr;
								};
							
							_ldrClass = selectRandom _classArr;
							_ldrGp = createGroup _side;
							leaderHQC = _ldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
							leaderHQC setDir _dir;
							(group leaderHQC) setVariable ["RydHQ_MyDir",_dir];
							(group leaderHQC) setVariable ["RydHQ_MyFactions",_myFactions];	
							};*/
						}
					};
					
				case (1) :
					{
					switch (_foreachIndex) do
						{
						case (0) :
							{
							_cntF = count _facM;
							_ldrIx = _foreachIndex + 1;
							_myFactions = [];
							
							if (_cntF > _cntL) then
								{
								for "_i" from _ldrIx to _cntF step _cntL do
									{
									_myFactions pushBack (((_facM select (_i - 1)) select 0) select 0) 
									};
								}
							else
								{
								_facIx = _foreachIndex mod _cntF;
								_myFactions = [(((_facM select _facIx) select 0) select 0)];
								};

							_fac = selectRandom _myFactions;

							_classArr = [];
							
								{
								_cFac = getText (configFile >> "CfgVehicles" >> _x >> "faction");
								if (_fac isEqualTo _cFac) then
									{
									_classArr pushBack _x;
									}
								}
							foreach _ldrClassArr;
							
							if ((count _classArr) < 1) then
								{
								_classArr = _ldrClassArr;
								};
							
							_ldrClass = selectRandom _classArr;
							_ldrGp = createGroup _side;
							leaderHQC = _ldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
							leaderHQC setDir _dir;
							(group leaderHQC) setVariable ["RydHQ_MyDir",_dir];
							(group leaderHQC) setVariable ["RydHQ_MyFactions",_myFactions];
							
							if (RYD_WS_LeadersPoofItsMagic) then
								{
								removeAllWeapons leaderHQC;
								leaderHQC hideObject true;
								leaderHQC allowDamage false;
								leaderHQC addEventHandler ["HandleDamage",{0}];
								
								_fldrGp = createGroup _side;
								RydHQC_ExcludedG pushback _fldrGp;
								fakeLeaderHQC = _fldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
								fakeLeaderHQC setDir _dir;
								(group fakeLeaderHQC) setVariable ["RydHQ_MyDir",_dir];
								(group fakeLeaderHQC) setVariable ["RydHQ_MyFactions",_myFactions];
								
								[fakeLeaderHQC] call RYD_WS_HQGuard;
								};
							};
							
						case (1) :
							{
							_cntF = count _facM;
							_ldrIx = _foreachIndex + 1;
							_myFactions = [];
							
							if (_cntF > _cntL) then
								{
								for "_i" from _ldrIx to _cntF step _cntL do
									{
									_myFactions pushBack (((_facM select (_i - 1)) select 0) select 0) 
									};
								}
							else
								{
								_facIx = _foreachIndex mod _cntF;
								_myFactions = [(((_facM select _facIx) select 0) select 0)];
								};

							_fac = selectRandom _myFactions;

							_classArr = [];
							
								{
								_cFac = getText (configFile >> "CfgVehicles" >> _x >> "faction");
								if (_fac isEqualTo _cFac) then
									{
									_classArr pushBack _x;
									}
								}
							foreach _ldrClassArr;
							
							if ((count _classArr) < 1) then
								{
								_classArr = _ldrClassArr;
								};
							
							_ldrClass = selectRandom _classArr;
							_ldrGp = createGroup _side;
							leaderHQD = _ldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
							leaderHQD setDir _dir;
							(group leaderHQD) setVariable ["RydHQ_MyDir",_dir];
							(group leaderHQD) setVariable ["RydHQ_MyFactions",_myFactions];
							
							if (RYD_WS_LeadersPoofItsMagic) then
								{
								removeAllWeapons leaderHQD;
								leaderHQD hideObject true;
								leaderHQD allowDamage false;
								leaderHQD addEventHandler ["HandleDamage",{0}];
								
								_fldrGp = createGroup _side;
								RydHQD_ExcludedG pushback _fldrGp;
								fakeLeaderHQD = _fldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
								fakeLeaderHQD setDir _dir;
								(group fakeLeaderHQD) setVariable ["RydHQ_MyDir",_dir];
								(group fakeLeaderHQD) setVariable ["RydHQ_MyFactions",_myFactions];
								
								[fakeLeaderHQD] call RYD_WS_HQGuard;
								};
							};
							
						/*case (2) :
							{
							_cntF = count _facM;
							_ldrIx = _foreachIndex + 1;
							_myFactions = [];
							
							if (_cntF > _cntL) then
								{
								for "_i" from _ldrIx to _cntF step _cntL do
									{
									_myFactions pushBack (((_facM select (_i - 1)) select 0) select 0) 
									};
								}
							else
								{
								_facIx = _foreachIndex mod _cntF;
								_myFactions = [(((_facM select _facIx) select 0) select 0)];
								};

							_fac = selectRandom _myFactions;

							_classArr = [];
							
								{
								_cFac = getText (configFile >> "CfgVehicles" >> _x >> "faction");
								if (_fac isEqualTo _cFac) then
									{
									_classArr pushBack _x;
									}
								}
							foreach _ldrClassArr;
							
							if ((count _classArr) < 1) then
								{
								_classArr = _ldrClassArr;
								};
							
							_ldrClass = selectRandom _classArr;
							_ldrGp = createGroup _side;
							leaderHQF = _ldrGp createUnit [_ldrClass, _x, [], 0, "NONE"];
							leaderHQF setDir _dir;
							(group leaderHQF) setVariable ["RydHQ_MyDir",_dir];
							(group leaderHQF) setVariable ["RydHQ_MyFactions",_myFactions];	
							};*/
						}
					};
				};
			}
		foreach _ldrPositions;
		}
	foreach [_sideA,_sideB];

		{
		_wPos = _x;		
		_val0 = switch (_locT select _foreachIndex) do
			{
			case ("namecitycapital"): {(random [7, 10, 12])};
			case ("namecity"): {(random [4, 6, 8])};
			case ("namevillage"): {(random [2, 4, 6])};
			case ("namelocal"): {(random [1, 2, 4])};
			case ("hill"): {(random [1, 1, 4])};
			default {(random [1, 2, 3])};
			};
		
		RydBBa_Str pushBack [_x,(_val0 * (random [0.75, 1, 1.5])),(((_relPos distance2D _posA) > (_relPos distance2D _x)) or {(({((_x distance _wPos) < 1000)} count [LeaderHQ,LeaderHQB]) > 0) and {(({((_x distance _wPos) < 1000)} count [LeaderHQC,LeaderHQD]) == 0)}})];
		RydBBb_Str pushBack [_x,(_val0 * (random [0.75, 1, 1.5])),(((_relPosB distance2D _posB) > (_relPosB distance2D _x)) or {(({((_x distance _wPos) < 1000)} count [LeaderHQC,LeaderHQD]) > 0) and {(({((_x distance _wPos) < 1000)} count [LeaderHQ,LeaderHQB]) == 0)}})];
		}
	foreach _web;	
		
		{
		_sideIx = _foreachIndex;
		
		_facM = switch (_sideIx) do
			{
			case (0) : {_dirL = _dirL0;RYD_WS_selFactionsA};
			case (1) : {_dirL = _dirL0 + 180;RYD_WS_selFactionsB};
			};			

		_side = _x;
		_dir = _dirL + 180;		
		
		_airClasses = switch (_x) do
			{
			case (west) : {RYD_WS_B_Air_G2 + RYD_WS_Air_class_B};
			case (east) : {RYD_WS_O_Air_G2 + RYD_WS_Air_class_O};
			case (resistance) : {RYD_WS_I_Air_G2 + RYD_WS_Air_class_I};
			};
						
			{
			_fac = toLower (getText (_vehClass >> _x >> "faction"));
			
			if not (({_fac == ((_x select 0) select 0)} count _facM) > 0) then
				{
				_airClasses set [_foreachIndex,0]
				}
			}
		foreach _airClasses;
		
		_airClasses = _airClasses - [0];
			
		_staticClasses = switch (_x) do
			{
			case (west) : {RYD_WS_B_Static_G2 + RYD_WS_Static_class_B};
			case (east) : {RYD_WS_O_Static_G2 + RYD_WS_Static_class_O};
			case (resistance) : {RYD_WS_I_Static_G2 + RYD_WS_Static_class_I};
			};
			
			{
			_fac = toLower (getText (_vehClass >> _x >> "faction"));
			
			if not (({_fac == ((_x select 0) select 0)} count _facM) > 0) then
				{
				_staticClasses set [_foreachIndex,0]
				}
			}
		foreach _staticClasses;
		
		_staticClasses = _staticClasses - [0];
			
		_supportClasses = switch (_x) do
			{
			case (west) : {RYD_WS_B_Support_G2 + RYD_WS_Support_class_B};
			case (east) : {RYD_WS_O_Support_G2 + RYD_WS_Support_class_O};
			case (resistance) : {RYD_WS_I_Support_G2 + RYD_WS_Support_class_I};
			};
			
			{
			_fac = toLower (getText (_vehClass >> _x >> "faction"));
			
			if not (({_fac == ((_x select 0) select 0)} count _facM) > 0) then
				{
				_supportClasses set [_foreachIndex,0]
				}
			}
		foreach _supportClasses;
		
		_supportClasses = _supportClasses - [0];
		
		_cargoClasses = switch (_x) do
			{
			case (west) : {RYD_WS_B_NCCargo_G2 + RYD_WS_NCCargo_class_B};
			case (east) : {RYD_WS_O_NCCargo_G2 + RYD_WS_NCCargo_class_O};
			case (resistance) : {RYD_WS_I_NCCargo_G2 + RYD_WS_NCCargo_class_I};
			};
			
			{
			_fac = toLower (getText (_vehClass >> _x >> "faction"));
			
			if not (({_fac == ((_x select 0) select 0)} count _facM) > 0) then
				{
				_cargoClasses set [_foreachIndex,0]
				}
			}
		foreach _cargoClasses;
		
		_cargoClasses = _cargoClasses - [0];
		
		//_gpsA = [];
		//_gpsB = [];
		//_fcsA = [];
		//_fcsB = [];
		
			{
			_ldrs0 = if (_sideIx == 0) then
				{
				[LeaderHQ,LeaderHQB]
				}
			else
				{
				[LeaderHQC,LeaderHQD]
				};
								
			_amnt = floor (random (2 * RYD_WS_Scale));
			
			if (_foreachIndex == 3) then
				{
				_amnt = 2 + (ceil (random (3 * RYD_WS_Scale)))
				};
				
			//diag_log format ["classes: %1",[_foreachindex,count _x]];
			
			_mainPos = _battlefield select _sideIx;
			
			for "_j" from 1 to 3 do
				{
				_myPos = _mainPos getPos [(-1000 + (_j * 500)),(_dirL + 90)];
			
				for "_i" from 1 to _amnt do
					{
					switch (_foreachIndex) do
						{
						case (0) :
							{
							if ((count _airClasses) > 0) then
								{
								_gp = [_myPos,_dir,_airClasses,_ldrs0] call RYD_WS_SpawnAir;
								
								if not (isNull _gp) then
									{
									_vh = assignedVehicle (leader _gp);
									_name = getText (configFile >> "CfgVehicles" >> (typeof _vh) >> "displayName");
									_gp setVariable ["RYD_WS_myKind",_name + " crew"];
									switch (_sideIx) do
										{
										case (0) : 
											{
											_gpsA set [(count _gpsA),_gp];
											_fcsA = _fcsA + (units _gp)
											};
											
										case (1) : 
											{
											_gpsB set [(count _gpsB),_gp];
											_fcsB = _fcsB + (units _gp)
											};
										};
									}
								}
							};
							
						case (1) :
							{
							if ((count _staticClasses) > 0) then
								{
								_stPos = +_myPos;
									
								_gp = [_stPos,_dir,_staticClasses,_ldrs0] call RYD_WS_SpawnStatic;

								if not (isNull _gp) then
									{
									_vh = assignedVehicle (leader _gp);
									_name = getText (configFile >> "CfgVehicles" >> (typeof _vh) >> "displayName");
									_gp setVariable ["RYD_WS_myKind",_name + " crew"];
									
									switch (_sideIx) do
										{
										case (0) : 
											{
											_gpsA set [(count _gpsA),_gp];
											_fcsA = _fcsA + (units _gp)
											};
											
										case (1) : 
											{
											_gpsB set [(count _gpsB),_gp];
											_fcsB = _fcsB + (units _gp)
											};
										};
									}
								}
							};
							
						case (2) :
							{
							if ((count _supportClasses) > 0) then
								{
								_gp = [_myPos,_dir,_supportClasses,_ldrs0] call RYD_WS_SpawnSupport;
								
								if not (isNull _gp) then
									{
									_vh = assignedVehicle (leader _gp);
									_name = getText (configFile >> "CfgVehicles" >> (typeof _vh) >> "displayName");
									_gp setVariable ["RYD_WS_myKind",_name + " crew"];
									
									switch (_sideIx) do
										{
										case (0) : 
											{
											_gpsA set [(count _gpsA),_gp];
											_fcsA = _fcsA + (units _gp)
											};
											
										case (1) : 
											{
											_gpsB set [(count _gpsB),_gp];
											_fcsB = _fcsB + (units _gp)
											};
										}
									}
								};				
							};
							
						case (3) :
							{
							if ((count _cargoClasses) > 0) then
								{
								_gp = [_myPos,_dir,_cargoClasses,_ldrs0] call RYD_WS_SpawnSupport;
								
								if not (isNull _gp) then
									{
									_vh = assignedVehicle (leader _gp);
									_name = getText (configFile >> "CfgVehicles" >> (typeof _vh) >> "displayName");
									_gp setVariable ["RYD_WS_myKind",_name + " crew"];
									
									switch (_sideIx) do
										{
										case (0) : 
											{
											_gpsA set [(count _gpsA),_gp];
											_fcsA = _fcsA + (units _gp)
											};
											
										case (1) : 
											{
											_gpsB set [(count _gpsB),_gp];
											_fcsB = _fcsB + (units _gp)
											};
										}
									}
								};				
							};
						}
					}
				}
			}	
		foreach [_airClasses,_staticClasses,_supportClasses,_cargoClasses];		
		}
	foreach [_sideA,_sideB];
	
		{
		_mainIx = _foreachIndex;
		_mainPos = _battlefield select _foreachIndex;
		_eyeOfBattle = _battlefield select 2;

		if ((_mainPos distance _eyeOfBattle) < 500) then
			{
			_ix = 0;
			if (_foreachIndex == 0) then
				{
				_ix = 1
				};
				
			_eyeOfBattle = _battlefield select _ix
			};
			
		_dst = _mainPos distance _eyeOfBattle;
		
			{
				{
				_type = _x select 1;
				
				_faction = _type >> "faction";

				_faction = if (isText _faction) then 
					{
					(toLower (getText _faction))
					}
				else
					{
					""
					};
				
				_potLeaders = [];
				_allFA = 1;
				
					{
					_allFA = _allFA + ((group _x) getVariable ["RYD_WS_myForces",0])
					}
				foreach [LeaderHQ,LeaderHQB];
				
				_allFB = 1;
				
					{
					_allFB = _allFB + ((group _x) getVariable ["RYD_WS_myForces",0])
					}
				foreach [LeaderHQC,LeaderHQD];
				
					{
					_myFacs = (group _x) getVariable ["RydHQ_MyFactions",[""]];
					if (_faction in _myFacs) then
						{
						_allF = if (_foreachIndex < 3) then
							{
							(_allFA max 1)
							}
						else
							{
							(_allFB max 1)
							};
							
						_potLeaders pushBack _x;
						_potLeaders pushBack (_allF/(((group _x) getVariable ["RYD_WS_myForces",0]) + 1))
						};
					}
				foreach [LeaderHQ,LeaderHQB,LeaderHQC,LeaderHQD];
				
				if ((count _potLeaders) < 1) exitWith {};

				_myLeader = selectRandomWeighted _potLeaders;
				_currentForces = (group _myLeader) getVariable ["RYD_WS_myForces",0];
				(group _myLeader) setVariable ["RYD_WS_myForces",(_currentForces + 1)];
				
				_mainPos = position _myLeader;				
				//diag_log format ["GP: %1",_x];
				_posL = _mainPos;
				
				_dir = [_mainPos,_eyeOfBattle,10] call RYD_AngTowards;
				
				if (_x select 3) then
					{
					_posL = [_posL,_dir + 190 - (random 20),(((random (_dst/3)) + (random (_dst/3))) min 2000) max 1000] call RYD_PosTowards2D
					};
											
				_posL = [_posL,50,350,100,50] call RYD_WS_FindLandPos;
								
				_spawnPos = [_posL,0,300,12,0,5,0,[],[_posL,_posL]] call BIS_fnc_findSafePos;
				
				_spawnPos set [2,0];	
				
				_side = _x select 0;
				
				_gp = [_spawnPos,_side,_type,_dir,true] call RYD_WS_SpawnGroupSafe;

				switch (_myLeader) do
					{
					case (LeaderHQ) : {RydHQ_Included pushBack _gp};
					case (LeaderHQB) : {RydHQB_Included pushBack _gp};
					case (LeaderHQC) : {RydHQC_Included pushBack _gp};
					case (LeaderHQD) : {RydHQD_Included pushBack _gp};
					case (LeaderHQE) : {RydHQE_Included pushBack _gp};
					case (LeaderHQF) : {RydHQF_Included pushBack _gp};
					};
				
				_gp setVariable ["RYD_WS_myKind",_x select 2];
				
				_prog = _prog + 1;
				
				progressLoadingScreen (0.5 + (_prog/_sum));
				
				if not (isNull _gp) then
					{
					switch (_mainIx) do
						{
						case (0) : 
							{
							_gpsA set [(count _gpsA),_gp];
							_fcsA = _fcsA + (units _gp)
							};
							
						case (1) : 
							{
							_gpsB set [(count _gpsB),_gp];
							_fcsB = _fcsB + (units _gp)
							};
						};
					}
				}
			foreach _x	
			}
		foreach _x
		}
	foreach _forces;
	
		{
		addSwitchableUnit _x;
		_x setVariable ["MARTA_showRules",[(RYD_WS_FacA select 1),1,(RYD_WS_FacB select 1),0]];
		_x setVariable ["RYD_WS_Aside",true];
		}
	foreach _fcsA;
	
	_player = _fcsA select (floor (random (count _fcsA)));

	_player setVariable ["WS_myName",name _player];

	selectPlayer _player;

	RYD_WS_ForcesA = _fcsA;
	RYD_WS_ForcesB = _fcsB;

	RYD_WS_GroupsA = _gpsA;
	RYD_WS_GroupsB = _gpsB;

	player setName profileName;
	};
	
RYD_WS_CigaretteTime = 
	{
	_gp = _this select 0;
	_cTime = param [1, [10,110],[[]],[2]];
	_pos = position (leader _gp);

	sleep ((_cTime select 0) + (random (_cTime select 1)));
	if (isNull _gp) exitWith {};
	if (({(alive _x)} count (units _gp)) < 1) exitWith {};
	
	waitUntil
		{
		sleep 5;
				
		if (isNull _gp) exitWith {true};
		if (({(alive _x)} count (units _gp)) < 1) exitWith {true};
		if not (isNull ((leader _gp) findNearestEnemy (leader _gp))) exitWith {true};
		
		((({((_x distance2D _pos) > 500)} count (units _gp)) > 0))
		};
		
	if (isNull _gp) exitWith {};
	if (({(alive _x)} count (units _gp)) < 1) exitWith {};
	if not (isNull ((leader _gp) findNearestEnemy (leader _gp))) exitWith {true};

	_gp setCurrentWaypoint [_gp,(currentWaypoint _gp) + 1];
	};
	
RYD_WS_HQGuard = 
	{
	private ["_excl","_minus","_blds","_HQHouse","_positions","_ix","_leaderPos","_gArr","_infG","_guard1","_pos","_dir","_posL","_spawnPos","_side","_type","_gp","_units","_uPos","_uGp",
	"_unit","_uDir","_watchPos","_uPosASL","_cPosASL","_isLOS","_pPositions","_am","_mPos","_pPos","_ct","_wp","_vehG","_vehArr","_guard2"];
	
	params ["_unit"];
	
	_excl = switch (true) do
		{
		case (_unit in [leaderHQ,fakeLeaderHQ]) :  {RydHQ_ExcludedG};
		case (_unit in [leaderHQB,fakeLeaderHQB]) :  {RydHQB_ExcludedG};
		case (_unit in [leaderHQC,fakeLeaderHQC]) :  {RydHQC_ExcludedG};
		case (_unit in [leaderHQD,fakeLeaderHQD]) :  {RydHQD_ExcludedG};
		default {[]}
		};
	
	_pos = position _unit;
	_dir = getDir _unit;
	
	_minus = nearestObjects [_pos,["PowerLines_Wires_base_F","PowerLines_Small_base_F","Lamps_base_F","Piers_base_F","Land_NavigLight"],500];
	_blds = _pos nearObjects ["House",500];	
	_blds = _blds - _minus;
	
		{
		if not ((count (_x buildingPos -1)) > 0) then
			{
			_blds set [_foreachIndex,objNull]
			};
		}
	foreach _blds;
	_blds = _blds - [objnull];
	
	_HQHouse = if ((count _blds) > 0) then
		{
		(selectRandom _blds)
		}
	else
		{
		objNull
		};
	
	_positions = [];
	if not (isNull _HQHouse) then
		{
		_positions = _HQHouse buildingPos -1;
		_ix = floor (random (count _positions));
		
		_leaderPos = _positions select _ix;
		_positions set [_ix,0];
		_positions = _positions - [0];
		
		_unit setPosATL _leaderPos;
		};
		
	_pos = position _unit;
		
/*_mk = "PMark_" + (str (position _unit));
			_mk = createMarker [_mk,(position _unit)];
			_mk setMarkerColor "ColorRed";
			_mk setMarkerShape "ICON";
			_mk setMarkerType "mil_dot";
			_mk setMarkerSize [0.75,0.75];
			_mk setMarkerText (str _unit);	*/	
		
	
	_gArr = if ((side _unit) == RYD_WS_SideA) then
		{
		+RYD_WS_HQGuardsA
		}
	else
		{
		+RYD_WS_HQGuardsB
		};
		
	_infG = [];
	
		{
		if not (_x select 2) then
			{
			_infG pushBack [(_x select 0),(_x select 1)]
			}
		}
	foreach (_gArr select 0);
	
	_guard1 = selectRandom _infG;
	
	_posL = [_pos,10,100,100,25] call RYD_WS_FindLandPos;
					
	_spawnPos = [_posL,0,200,12,0,5,0,[],[_posL,_posL]] call BIS_fnc_findSafePos;
	_spawnPos set [2,0];	
	
	_side = _guard1 select 0;
	_type = _guard1 select 1;
	
	_gp = [_spawnPos,_side,_type,_dir,true] call RYD_WS_SpawnGroupSafe;
	
	_units = units _gp;

	for "_i" from 0 to (((count _positions) min (count _units)) - 1) do
		{
		_ix = floor (random (count _positions));
		
		_uPos = _positions select _ix;
		_positions set [_ix,0];
		_positions = _positions - [0];
		
		_uGp = createGroup _side;
		_excl pushBack _uGp;
		_unit = _units select _i;
		[_unit] joinSilent _uGp;
		_unit setPosATL _uPos;
		_uDir = random 360;
		
		_watchPos = [];
		_uPosASL = ATLtoASL _uPos;

		for "_i" from _uDir to (_uDir + 315) step 45 do
			{
			_cPosASL = ATLtoASL (_uPos getPos [5,_i]);
			_isLOS = [_cPosASL,_cPosASL,1.75,20,_unit,objNull] call RYD_WS_LOSCheck;
			
			if (_isLOS) then
				{
				_isLOS = [_uPosASL,_cPosASL,1.75,1.75,_unit,objNull] call RYD_WS_LOSCheck;
				
				if (_isLOS) then
					{
					_watchPos = ASLtoATL _cPosASL
					}
				};
				
			if ((count _watchPos) > 0) exitWith
				{
				_uDir = _uPosASL getDir _cPosASL
				};
			};

		if ((count _watchPos) == 0) then
			{
			_uDir = random 360;
			for "_i" from _uDir to (_uDir + 315) step 45 do
				{
				_cPosASL = ATLtoASL (_uPos getPos [5,_i]);

				_isLOS = [_uPosASL,_cPosASL,1.75,1.75,_unit,objNull] call RYD_WS_LOSCheck;					
				if (_isLOS) exitWith 
					{
					_watchPos = ASLtoATL _cPosASL;
					_uDir = _uPosASL getDir _cPosASL
					};
				};
			};				
			
		_unit setDir _uDir;
		_uGp setFormDir _uDir;
		};
	
	if (({alive _x} count (units _gp)) > 0) then
		{
		_excl pushBack _gp;
		_pPositions = [_pos];
		_am = 1 + (ceil (random 3));
		
		for "_i" from 1 to _am do
			{
			_mPos = +_pos;			
			_pPos = _mPos getPos [(100 * (sqrt (random 1))),random 360];
			
			_ct = 0;
			
			while {(surfaceIsWater _pPos)} do
				{
				_pPos = _mPos getPos [((100 + _ct) * (sqrt (random 1))),random 360];
				_ct = _ct + 1;
				if (_ct > 100) exitWith 
					{
					_pPos = _mPos
					};
				};
				
			_pPos = [_pPos,4,100,6, 0, 0.3, 0,[],[[(_pPos select 0),(_pPos select 1)],[(_pPos select 0),(_pPos select 1)]]] call BIS_fnc_findSafePos;			
			_pPos set [2,0];
			_pPositions pushBack _pPos;
			};		
				
			{
			_wp = _gp addWaypoint [_x,5];
			_wp setWaypointType "SAD";
			_wp setWaypointBehaviour "AWARE";
			_wp setWaypointCombatMode "RED";
			_wp setWaypointSpeed "LIMITED";
			_wp setWaypointFormation "DIAMOND";
			_wp setWaypointTimeout [20,60,120];
			
			/*_mk = "PMark_" + (str _x);
			_mk = createMarker [_mk,_x];
			_mk setMarkerColor "ColorRed";
			_mk setMarkerShape "ICON";
			_mk setMarkerType "mil_dot";
			_mk setMarkerSize [0.75,0.75];
			_mk setMarkerText (str _gp)*/
			}
		foreach _pPositions;
		
		_wp setWaypointStatements ["true","nul = [(group this)] spawn RYD_WS_CigaretteTime"];
		
		_wp = _gp addWaypoint [(_pPositions select ((count _pPositions) - 1)),5];
		_wp setWaypointType "DISMISS";
		_wp setWaypointBehaviour "SAFE";
		_wp setWaypointCombatMode "RED";
		_wp setWaypointSpeed "LIMITED";
		_wp setWaypointFormation "DIAMOND";			
						
		_wp = _gp addWaypoint [_pos, 0];
		_wp setWaypointType "CYCLE";
		}
	else
		{
		deleteGroup _gp
		};

	_vehG = [];
	_vehArr = _gArr select 2;
	//_vehArr appEnd (_gArr select 3);
	
		{
		if not (_x select 2) then
			{
			_vehG pushBack [(_x select 0),(_x select 1)]
			}
		}
	foreach _vehArr;

	_guard2 = selectRandom _vehG;
	
	_posL = [_pos,10,50,100,25] call RYD_WS_FindLandPos;
					
	_spawnPos = [_posL,0,50,12,0,5,0,[],[_posL,_posL]] call BIS_fnc_findSafePos;
	_spawnPos set [2,0];	
	
	_side = _guard2 select 0;
	_type = _guard2 select 1;
	
	//_gp = [_spawnPos,_side,_type,_dir,true] call RYD_WS_SpawnGroupSafe;
	_gp = [_spawnPos,_side,_type] call BIS_fnc_spawnGroup;	
	_excl pushBack _gp;
	
/*_mk = "PMark_" + (str (position (leader _gp)));
			_mk = createMarker [_mk,(position (leader _gp))];
			_mk setMarkerColor "ColorRed";
			_mk setMarkerShape "ICON";
			_mk setMarkerType "mil_box";
			_mk setMarkerSize [0.75,0.75];
			_mk setMarkerText (str (typeOf (vehicle (leader _gp))));	*/
	
	//_gp = [(position RYD_TS_Town),(side RYD_TS_Player), (configfile >> "CfgGroups" >> "West" >> "BLU_F" >> "Infantry" >> "BUS_ReconTeam")] call BIS_fnc_spawnGroup;	
	//RYD_WS_HQGuardsA//"Gps: [WEST,bin\config.bin/CfgGroups/West/BLU_T_F/Support/B_T_Support_Mort,false,""Mortar Team""]"
	};